<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第十二课 &mdash; Haiku 中文文档</title>
    
    <link rel="stylesheet" href="../../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="Haiku 中文文档" href="../../../index.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../../../index.html">
          <span>Haiku 中文文档</span></a></h1>
        <h2 class="heading"><span>第十二课</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="id1">
<h1>第十二课<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>## 属性</p>
<p>Haiku 所使用的 Be 文件系统允许文件拥有扩展属性。这些属性是 <em>元数据（metadata）</em> ，即文件相关信息，但并属于文件内容的一部分。尽管许多其他的操作系统在它们的文件系统中实现了这一特性，但是它们并不像 Haiku 这般那么普遍的加以使用。</p>
<p>属性所提供的灵活性可能起初并不那么明显。例如， MP3 文件可以有不同属性，如艺术家，专辑，等等。对于 MP3 文件，则不需要这种特别的标签读取代码过程。Haiku 中的电子邮件存放在单独文件中，因此搜索会比较繁琐，例如，对于一段时间力接收的某个人发送的所有邮件。Person 文件，用于存储联系人信息，它们基本上都是零字节文件，所有相关的信息都存储在属性中。一些联系人管理软件，例如 Mr.Peeps!，扩展了用于联系人文件的属性数量，甚至将它们保存为常规数据。</p>
<p>用于处理属性的主要 C++ 函数是由 BNode 类所提供的方法。
<tt class="docutils literal"><span class="pre">`C++</span>
<span class="pre">status_t</span> <span class="pre">GetAttrInfo(const</span> <span class="pre">char</span> <span class="pre">*name,</span> <span class="pre">attr_info</span> <span class="pre">*info)</span> <span class="pre">const;</span>
<span class="pre">`</span></tt>
获取名称为 name 的属性类型和大小，并把它们放到 info 中相应的属性，在开始调用时，必须已经为其分配空间。如果节点没有这个属性，那么将返回 B_ENTRY_NOT_FOUND，如果 BNode 未初始化，将会返回 B_FILE_ERROR。如果成功则返回 B_OK。下述是 attr_info 结构体声明：
<a href="#id2"><span class="problematic" id="id3">``</span></a><a href="#id4"><span class="problematic" id="id5">`</span></a>C++
typedef struct attr_info
{</p>
<blockquote>
<div>uint32   type;
off_t    size;</div></blockquote>
<p>} attr_info;</p>
<p>ssize_t ReadAttr(const char* name, type_code type, off_t offset,void* buffer, size_t length);
<tt class="docutils literal"><span class="pre">`</span>
<span class="pre">ReadAttr()</span> <span class="pre">从属性</span> <span class="pre">name</span> <span class="pre">中读取数据，并将其拷贝至长度为</span> <span class="pre">length</span> <span class="pre">字节到</span> <span class="pre">buffer</span> <span class="pre">。在这里，并没有使用</span> <span class="pre">offset</span> <span class="pre">。和</span> <span class="pre">Bmessage</span> <span class="pre">标识符常量相似，type</span> <span class="pre">参数可以是任何四字节整型值，但是它通常是</span> <span class="pre">TypeConstants.h</span> <span class="pre">中预定义的常量，例如</span> <span class="pre">B_STRING_TYPE，或者</span> <span class="pre">B_INT32_TYPE。返回值为所读取到的字节数。</span>
<span class="pre">```C++</span>
<span class="pre">ssizet</span> <span class="pre">WriteAttr(const</span> <span class="pre">char*</span> <span class="pre">name,</span> <span class="pre">type_code</span> <span class="pre">type,</span> <span class="pre">off_t</span> <span class="pre">offset,</span> <span class="pre">void*</span> <span class="pre">buffer,</span> <span class="pre">size_t</span> <span class="pre">length);</span>
<span class="pre">`</span></tt>
WriteAttr() 的运用与 ReadAttr() 基本相同，除了其中的属性将被擦除，并且取而代之的是 buffer 中的数据。备注：&lt;strong&gt;索引属性，无法通过查询进行访问，而且其不会多于255字节&lt;/strong&gt;。它们必须为以下几种类型：string，int32，uint32，int64，uint64，float，或者 double。
<tt class="docutils literal"><span class="pre">`C++</span>
<span class="pre">status_t</span> <span class="pre">RemoveAttr(const</span> <span class="pre">char*</span> <span class="pre">name);</span>
<span class="pre">`</span></tt>
该方法删除指定的属性，如果成功，则返回B_OK。
<tt class="docutils literal"><span class="pre">`C++</span>
<span class="pre">status_t</span> <span class="pre">RenameAttr(const</span> <span class="pre">char*</span> <span class="pre">oldname,</span> <span class="pre">const</span> <span class="pre">char</span> <span class="pre">*newname);</span>
<span class="pre">`</span></tt>
它更多的是移动而不是重命名。需要注意的是，如果已经存在了一个 newname 属性，该操作就会失败。
<tt class="docutils literal"><span class="pre">`C++</span>
<span class="pre">status_t</span> <span class="pre">ReadAttrString(const</span> <span class="pre">char*</span> <span class="pre">name,</span> <span class="pre">BString</span> <span class="pre">*out)</span> <span class="pre">const;</span>
<span class="pre">status_t</span> <span class="pre">WriteAttrString(const</span> <span class="pre">char*</span> <span class="pre">name,</span> <span class="pre">const</span> <span class="pre">Bstring*</span> <span class="pre">data);</span>
<span class="pre">`</span></tt>
这些还未有文档说明的函数在您处理字符串属性时非常方便。在读取属性函数中，name 属性中的数据将存放在 out 中，而写入属性函数中，这些数据则写入磁盘。</p>
<p>下面是读取属性代码的一个示例。在这个实例中，我们将要读取 E-mail Name 属性。
<a href="#id6"><span class="problematic" id="id7">``</span></a><a href="#id8"><span class="problematic" id="id9">`</span></a>C++
#include &lt;fs_attr.h&gt;
#include &lt;Node.h&gt;
#include &lt;String.h&gt;</p>
<p>BString
GetEmailName(const char* path)
{</p>
<blockquote>
<div><p>BString out;
BNode node(path);
if (node.InitCheck() != B_OK)</p>
<blockquote>
<div>return out;</div></blockquote>
<p>// 以下代码用于保证属性存在，并且其大小合适。
attr_info attrInfo;
if (node.GetAttrInfo(“META:name”, &amp;attrInfo) != B_OK)</p>
<blockquote>
<div>return out;</div></blockquote>
<p>// BString::LockBuffer() 和 UnlockBuffer() 允许我们直接访问
// BString 使用的内部字符buffer。LockBuffer() 接受的参数为
// 字符buffer 的最大大小。
char* nameBuffer = out.LockBuffer(attrInfo.size + 1);
node.ReadAttr(“META:name”, attrInfo.type, 0, nameBuffer,</p>
<blockquote>
<div>attrInfo.size);</div></blockquote>
<p>nameBuffer[attrInfo.size] = ‘0’;
out.UnlockBuffer();</p>
<p>return out;</p>
</div></blockquote>
<div class="section" id="id10">
<h2>}<a class="headerlink" href="#id10" title="Permalink to this headline">¶</a></h2>
<p>对于任意的属性，以上代码都运行的很好。但是，有一些特别的属性，它们属于系统标准，如用于简化我们实时使用，帮助入门开发人员从记忆最常用的属性名称解脱出来而创建的类。它们包括图标和文件类型。它们都以 BNodeInfo 类的形式提供。</p>
<p>## BNodeInfo
<tt class="docutils literal"><span class="pre">`C++</span>
<span class="pre">status_t</span> <span class="pre">GetAppHint(entry_ref*</span> <span class="pre">app_ref);</span>
<span class="pre">status_t</span> <span class="pre">SetAppHint(const</span> <span class="pre">entry_ref</span> <span class="pre">app_ref);</span>
<span class="pre">`</span></tt>
系统中的文件提示，其指明了哪个程序可以用于打开特定文件。app_ref 就是该提示，因为它指定的可能并非一个应用，或者一些其它问题会阻止它打开文件。基于以上问题，该信息存储于属性“BEOS:PATH”。但以上两个方法并不常用。
<a href="#id11"><span class="problematic" id="id12">``</span></a><a href="#id13"><span class="problematic" id="id14">`</span></a>C++
status_t GetIcon(Bbitmap* icon, icon_size size = B_LARGE_ICON);
status_t SetIcon(const Bbitmap* icon, icon_size size = B_LARGE_ICON);</p>
<p>status_t GetIcon(uint8 <a href="#id15"><span class="problematic" id="id16">**</span></a>data, size_t* size, type_code* type) const;
status_t SetIcon(const uint8* data, size_t size);</p>
<p>static status_t GetTrackerIcon(entry_ref* ref, Bbitmap* icon, icon_size which = B_LARGE_ICON);
<tt class="docutils literal"><span class="pre">`</span>
<span class="pre">前两个方法直接作用于文件属性。“BEOS:M:STD_ICON”保存了</span> <span class="pre">16x16</span> <span class="pre">像素的</span> <span class="pre">256</span> <span class="pre">色图标，而“BEOS:L:STD_ICON”则用于</span> <span class="pre">32x32</span> <span class="pre">像素</span> <span class="pre">256</span> <span class="pre">色图标。这些是所有</span> <span class="pre">BeOS</span> <span class="pre">系统的标准属性。Haiku</span> <span class="pre">引入了一个新的属性</span> <span class="pre">“BEOS:ICON”，用于存储矢量图标。与其他两个图标不同，这一图标的数据保存为</span> <span class="pre">Haiku</span> <span class="pre">矢量图标格式（HVIF）。这两个不使用</span> <span class="pre">BBitmap</span> <span class="pre">类的函数专门用于处理文件的矢量图标。GetTrackerIcon()</span> <span class="pre">获取</span> <span class="pre">Tracker</span> <span class="pre">显示的该文件图标，其可能与</span> <span class="pre">GetIcon()</span> <span class="pre">返回的不是同一图标，这在以后在进行解释。在多数情况下，如果您希望获取文件图标，只需使用</span> <span class="pre">GetTrackerIcon()</span> <span class="pre">即可。</span>
<span class="pre">```C++</span>
<span class="pre">status_t</span> <span class="pre">GetPreferredApp(char*</span> <span class="pre">signature,</span> <span class="pre">app_verb</span> <span class="pre">=</span> <span class="pre">B_OPEN);</span>
<span class="pre">status_t</span> <span class="pre">SetPreferredApp(char*</span> <span class="pre">signature,</span> <span class="pre">app_verb</span> <span class="pre">=</span> <span class="pre">B_OPEN);</span>
<span class="pre">`</span></tt>
这两个方法用于处理文件的首选应用。它们仅用于处理单个文件，通常并不用于文件的类型。这里所使用的属性为“BEOS:PREF_APP”。
<tt class="docutils literal"><span class="pre">`C++</span>
<span class="pre">status_t</span> <span class="pre">GetType(char*</span> <span class="pre">type);</span>
<span class="pre">status_t</span> <span class="pre">SetType(const</span> <span class="pre">char</span> <span class="pre">*type);</span>
<span class="pre">`</span></tt>
设置和获取文件类型。类型通常为 MIME 字符串。需要注意的是，如果属性不存在，可以调用全局函数 update_mime_info()。这两个方法处理的属性为“BEOS:TYPE”。</p>
<p>需要注意的是，有时使用 BNodeInfo 类的方法并没有 BNode 方便，后者直接作用于属性。为何？因为 BFile 是 BNode 的子类，通常很容易复用 BFile 对象，与偶其实使用 ReadAttrString() 和 WriteAttrString() 方法。</p>
<p>## 本地思考，全局而动</p>
<p>对于 Haiku 的高级用户来说，Haiku 可定制的方式之一就是我们刚刚谈到的文件属性处理。全局的设置存储在系统的 MIME 数据库，并且通过 BmimeType 类进行处理。而且，单个文件也可以自行定义来覆盖这些设置。</p>
<p>我们举个例子，例如 .xyz 文件可以由 XYZEdit 打开。该信息可以在 FileTypes 首选项或在程序中查看和修改，但是有一个文件 SpecialFile.xyz 总是希望使用 XYZOtherEdit 打开。这可以通过 Tracker 的 FileType 附加组件进行设置，即修改该文件的 “BEOS:PREF_APP” 属性。在双击 SpecialFile.xyz 时，Tracker 将会在 XYZOtherEdit 中打开文件。而其他所有的 .xyz 文件则在常用编辑器中打开。如果您希望将这一修改应用到所有的 .xyz 文件，则需要使用 BMimeType 类。我们将在后面学习该类。</p>
<p>## 聚焦思维</p>
<p>文件属性并不只存在于 BFS 文件系统。其他文件系统， 例如 XFS 和 ReiserFS 也具有该特性。而 Haiku 所不同的是，主流的操作系统（Linux，Windows，OSX）并没有倚重这一特性，如果您能够看到它们可以施展应用的广阔范围，这有点可惜。如果您在 Haiku 中闲逛过，您会发现它们在很多不同任务以不同的方式使用。下一课，我们将介绍一个与之相关的强大特性：查询。</p>
<p>## 深入了解</p>
<ul class="simple">
<li>在终端中使用命令 listattr 和 catattr ，查看这些文件都使用了什么属性：People 文件，应用程序，电子邮件，或者 MP3 文件。</li>
<li>如果您希望为任务清单应用创建一个 Task 文件，对于 Haiku，这些任务细节的存储方式就是使用属性。以电子邮件属性（ “MAIL:subject”，等）中所使用的常用命名方案为指导，对于任务文件信息，您该使用什么样的属性名称和类型？</li>
</ul>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2015, Han Pengfei.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>