

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>第二课 &mdash; Haiku 中文文档</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Haiku 中文文档" href="../../../index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../../index.html" class="icon icon-home"> Haiku Chinese Documents
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../关于Haiku.html">关于 Haiku</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id1">Haiku 好处在哪儿？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id2">为何选择 Haiku ？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id3">谁支持着 Haiku ？</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../开发.html">开发</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id2">用户指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id3">开发文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../开发入门.html">开发入门</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id2">手册相关</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id3">入门任务</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id4">当您找到任务</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id5">编写代码准备</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#git">获取 GIT 提交权限</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id6">深入阅读</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku编程学习.html">Haiku编程学习</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id1">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id2">目录</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id3">参考资料和工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku编程教程.html">Haiku 编程详解</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程教程.html#id1">前言</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程教程.html#id2">内容概览</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku指南.html">Haiku 指南</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#guides-haiku"><code class="docutils literal"><span class="pre">/guides/构建Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id1"><code class="docutils literal"><span class="pre">/guides/安装Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id2"><code class="docutils literal"><span class="pre">/guides/启动Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#guides"><code class="docutils literal"><span class="pre">/guides/日常任务</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id3"><code class="docutils literal"><span class="pre">/guides/虚拟化</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id4">其他指南</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku源码规范.html">Haiku 编码规范</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id2">规范概况</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id3">缩进和空格</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id4">杂项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id5">标识符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id6">变量声明</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#haiku-api">使用 Haiku 内置的 API，类型等</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id7">注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id8">许可和版权</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id9">无用代码和调试代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id10">其他的要求</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id11">风格检查工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../开发常见问题（FAQ）.html">开发常见问题（FAQ）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id1">我是一个程序员，希望可以帮忙，那么从何开始呢？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id4">是否有简单的引导任务？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id6">是否有特定的编程风格？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id7">如何创建和提交补丁？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#trac">为什么无法在 Trac 中创建任务单？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id8">使用哪些开发工具？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id9">是否有开发者邮件列表？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#irc">是否有 IRC 聊天室？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id10">我尝试进行测试，但是 Haiku 编译失败。接下来该如何操作？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id11">我想把一些东西集成到官方源之中，可以集成那些组件？该使用何种协议呢？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#beos-haiku">我希望可以把我的 BeOS 程序/驱动移植到 Haiku，该如何进行？</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Haiku图标指南.html">Haiku 图标指南</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id1">透视效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id2">光源效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id3">渐变效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id4">色彩效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id5">阴影效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id6">轮廓线</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id7">高亮效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id8">使用覆盖</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id9">细节</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id10">中立图标</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id4">在线资源</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../开发.html#id7">开发工具</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../开发.html#id8">其他系统交叉编译</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../文档.html">文档</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id2">用户文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id3">开发者文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id4">早期文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../文档.html#bebook-be">BeBook 和 Be 信札</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../文档.html#id5">其他</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">Haiku Chinese Documents</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
    <li>第二课</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id6">第二课</a><a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="contents topic" id="id2">
<p class="topic-title first">内容</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id6">第二课</a><ul>
<li><a class="reference internal" href="#c" id="id7">C++ 字符串</a></li>
<li><a class="reference internal" href="#id3" id="id8">关联容器</a><ul>
<li><a class="reference internal" href="#map" id="id9">map</a></li>
<li><a class="reference internal" href="#set" id="id10">set</a></li>
<li><a class="reference internal" href="#multimap-multiset" id="id11">multimap，multiset</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4" id="id12">容器适配器</a><ul>
<li><a class="reference internal" href="#queue" id="id13">queue</a></li>
<li><a class="reference internal" href="#priority-queue" id="id14">priority_queue</a></li>
<li><a class="reference internal" href="#stack" id="id15">stack</a></li>
</ul>
</li>
<li><a class="reference internal" href="#stl" id="id16">常用 STL 容器方法</a></li>
<li><a class="reference internal" href="#id5" id="id17">STL 和 标准库：那又怎样？</a></li>
</ul>
</li>
</ul>
</div>
<p>在第一节里面，我们学习了如何使用模板和一些标准模板库（STL）中非常灵活的数据容器来泛化类型处理。列表，队列和适量容器都非常适合存储顺序访问数据，但是对于 STL 来说，它们不仅仅只有三个。我们将要学习其他重要的容器类型，并了解它们彼此之间的异同点。我们还会涉及到可移植字符串类，它将提供比标准 C 函数更简单的字符串操作。在本节中，将会涉及到很多内容。遇到不懂得问题，请不要慌张，多读几遍，其义自现。</p>
<div class="section" id="c">
<h2><a class="toc-backref" href="#id7">C++ 字符串</a><a class="headerlink" href="#c" title="永久链接至标题">¶</a></h2>
<p>在开始了解其他容器之前，我们需要了解 C++ 标准库（Standard C++ library），其中用到了 STL 的内容，但是提供了其他有用的开发工具。而通用的字符串（string）类就是其中之一。</p>
<p>使用标准 C 函数，诸如 strcpy() 和 strstr() 等来处理字符串非常方便。Support Kit 中的 Bstring 类也提供了更为便利的操作，而 C++ string 类也同样。通常您可能会选用 Bstring 类，因为它会比较快，而且提供的操作也很多，并且整合到了 Haiku API，但是 C++ string 类提供了 Bstring 类中所没有的一些方法。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">string</span> <span class="nf">substr</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span> <span class="o">=</span> <span class="n">npos</span><span class="p">);</span>
</pre></div>
</div>
<p>substr() 返回一个以 pos 位置字符开始，并以 n 位置结束的子字符串。npos 是一个静态值，其值与字符串最大长度相等。毫无疑问，我们不会使用这两个默认值来调用该函数，因为它返回的还是整个字符串。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">size_t</span> <span class="n">find_first_not_of</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">find_first_not_of</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">find_first_not_of</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">find_first_not_of</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">find_last_not_of</span> <span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">str</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">npos</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">find_last_not_of</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">n</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">find_last_not_of</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">s</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">npos</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="kt">size_t</span> <span class="n">find_last_not_of</span> <span class="p">(</span><span class="kt">char</span> <span class="n">c</span><span class="p">,</span> <span class="kt">size_t</span> <span class="n">pos</span> <span class="o">=</span> <span class="n">npos</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>这两个函数用以查询 string 对象中第一（最末）个并不是函数中第一个参数所指定的字符所出现的位置。使用方法如下：</p>
<div class="highlight-cpp"><div class="highlight"><pre>std::string myString = “/boot/home/config/setting”;
size_t pos = myString.find_first_not_of(‘/’);
</pre></div>
</div>
<p>上述示例中，find_first_not_of() 中的 char 字符用于查找首个非反斜线的字符。该示例中 pos 的值为1。配合使用，那么它可以用于将文件路径拆分为一系列的目录名称，并且还不需要使用 strtok()。</p>
<p>C++ 字符串需要在 std 命名空间中使用，并且需要添加前缀 std::string 以便和常规 C 风格的字符串相区分。它们需要和 头文件一起使用。我们不会太多的使用 C++ 字符串，但是最好知道它们的存在，因为在其他平台上它们的使用非常广泛。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id8">关联容器</a><a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>由标准模板库提供的关联容器对我们来说是非常必要的，尤其是在容器中使用整型查询数据非常慢或无法实现时。尽管我们能够使用循环来手工查询数组，矢量容器或者其他顺序容器，但是速度非常慢。对于关连查询，它非常适用，但是如果您必须以这种方式重复查询信息，它可能会给你的代码带来严重的问题。</p>
<div class="section" id="map">
<h3><a class="toc-backref" href="#id9">map</a><a class="headerlink" href="#map" title="永久链接至标题">¶</a></h3>
<p>头文件：<cite>&lt;map&gt;</cite></p>
<p>map 容器以键值对为中心，例如查询值，那么也就获取到了相关的数据。map 对象的声明需要同时指明键和值得类型，如下所示：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">map</span><span class="o">&lt;</span><span class="n">Bstring</span><span class="p">,</span> <span class="n">int32</span><span class="o">&gt;</span> <span class="n">myMap</span><span class="p">;</span>
</pre></div>
</div>
<p>该声明创建了一个 map，其使用字符串来查询整型数据。使用字符串作为键来查询数据的 map 很常见。如果使用 std::string 或者 BString 作为键类型，那么也能够使用常规 C 类型的字符串来获取值。</p>
<div class="highlight-cpp"><div class="highlight"><pre>printf(“The value for %s is %d\n”, “Some value”, myMap[“Some value”]);
</pre></div>
</div>
<p>使用 map 时，唯一的要求就是键值必须是唯一的。map 对象中的元素实际上是另一个 STL 容器：pair。pair 容器仅将两种类型关联起来。可以通过 first 和 second 属性来访问这两个成对的类型。</p>
</div>
<div class="section" id="set">
<h3><a class="toc-backref" href="#id10">set</a><a class="headerlink" href="#set" title="永久链接至标题">¶</a></h3>
<p>set 容器和 map 容器非常相似，除了其中的值也是键，并且它们都做了排序。和 map 一样，set 中的所有元素都必须是唯一的。但是它并不经常使用，因为还有些容器要更加的灵活。通常使用 set 容器是为了更加快速的插入和查询。因为 set 容器的实现通常比较复杂，所以它可以提供这些特性。</p>
</div>
<div class="section" id="multimap-multiset">
<h3><a class="toc-backref" href="#id11">multimap，multiset</a><a class="headerlink" href="#multimap-multiset" title="永久链接至标题">¶</a></h3>
<p>这两种 set 和 map 类型不要求键所对应的实例是唯一的。调用 find() 方法仍然只返回给定键所对应的一个实例，但是这些容器包含了一个附加的方法，equal_range()，它返回一对迭代器，而这对迭代器所标定的范围提供了该指定键所对应的所有实例。</p>
</div>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id12">容器适配器</a><a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>标准模板库除了提供这些容器外，还提供了一些容器适配器。它们使用常规的STL容器为指定接口承担重任。</p>
<div class="section" id="queue">
<h3><a class="toc-backref" href="#id13">queue</a><a class="headerlink" href="#queue" title="永久链接至标题">¶</a></h3>
<p>queue 适配器通常建立在 deque 容器之上。从概念上说，对象从队列的尾部进去，而从头部出来，非常类似于排队买电影票。通常这种策略也称之为 FIFO，即先进先出。它提供的方法有 front()，back()，push_back()，和pop_front()。</p>
</div>
<div class="section" id="priority-queue">
<h3><a class="toc-backref" href="#id14">priority_queue</a><a class="headerlink" href="#priority-queue" title="永久链接至标题">¶</a></h3>
<p>priority_queue 适配器和 queue 适配器非常相似，但惟有的不同是：第一个进去的对象并不是第一个出来的。而第一个出来的是具有最高优先级的对象。通常可以用来担此重任的两种容器是 vector（默认的）和 deque。</p>
</div>
<div class="section" id="stack">
<h3><a class="toc-backref" href="#id15">stack</a><a class="headerlink" href="#stack" title="永久链接至标题">¶</a></h3>
<p>stack 可以建立在 deque，vector，和 list 容器之上。它用于 LIFO 处理，也就是后进先出。它可以比作自助餐厅堆叠的瓷盘：最后放在上面的盘子，将会第一个被拿走。</p>
</div>
</div>
<div class="section" id="stl">
<h2><a class="toc-backref" href="#id16">常用 STL 容器方法</a><a class="headerlink" href="#stl" title="永久链接至标题">¶</a></h2>
<p>STL提供了很多不同的容器，有时候我们很难记得它们哪个是哪个。幸运的是，它们有一组通用的方法。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">iterator</span> <span class="nf">begin</span><span class="p">();</span>
<span class="n">const_iterator</span> <span class="n">begin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>返回指向容器首个元素的迭代器。由于关联容器以升序排列所有元素，begin() 将会返回具有最小值的元素。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">iterator</span> <span class="nf">end</span><span class="p">();</span>
<span class="n">const_iterator</span> <span class="n">end</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>返回指向容器末尾元素之后的位置的迭代器 - 其和最后一个元素并不相同。该方法通常用于循环中，尤其是 for 循环。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">iterator</span> <span class="nf">rbengin</span><span class="p">();</span>
<span class="n">const_iterator</span> <span class="n">rbgin</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="n">iterator</span> <span class="nf">rend</span><span class="p">();</span>
<span class="n">const_iterator</span> <span class="n">rend</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>以上两个方法和 begin() 与 end() 完成同样的任务，但是它们从容器末尾向容器开头进行工作。rbegin() 返回容器的末尾元素，而 rend() 返回首个元素之前位置的迭代器。这两个方法和使用 reverse_iterator 的循环相一致，而并非一般循环。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">size_type</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>返回容器所包含对象的数量。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">size_type</span> <span class="n">max_size</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>max_size() 返回容器所能够包含的对象的最大数量，而这基于系统所设定的限制。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">empty</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>如果容器包含零个元素则返回真。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">resize</span><span class="p">(</span><span class="n">size_type</span> <span class="n">newSize</span><span class="p">,</span> <span class="n">T</span> <span class="n">from</span> <span class="o">=</span> <span class="n">T</span><span class="p">());</span>
</pre></div>
</div>
<p>修改容器大小以保存 newSize 个元素。如果这个数小于当前数目，那么多余的元素将被丢弃。如果新的大小比较大，那么将会以参数 from 传递的对象创建新的元素。如果未指定该参数，那么将会使用默认构造函数创建容器对象类型。该方法仅对顺序容器可用，例如 vector。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">reference</span> <span class="nf">front</span><span class="p">();</span>
<span class="k">const</span> <span class="n">reference</span> <span class="n">front</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
<span class="n">reference</span> <span class="nf">back</span><span class="p">();</span>
<span class="k">const</span> <span class="n">reference</span> <span class="n">back</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>以上两个方法分别返回容器的头部和尾部元素。它们返回的结果与 begin() 和 rbegin() 返回的迭代器是不同的。这两个方法不适用于关联容器，例如 map。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">vector</span><span class="p">,</span> <span class="n">deque</span>
<span class="n">reference</span> <span class="k">operator</span><span class="p">[</span><span class="n">size_type</span> <span class="n">index</span><span class="p">];</span>
<span class="n">const_reference</span> <span class="k">operator</span><span class="p">[</span><span class="n">size_type</span> <span class="n">index</span><span class="p">]</span> <span class="k">const</span><span class="p">;</span>

<span class="n">map</span>
<span class="n">T</span> <span class="o">&amp;</span> <span class="k">operator</span><span class="p">[</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">key</span><span class="p">];</span>
</pre></div>
</div>
<p>对 deque，vector 和 map 使用数组操作符将会返回指定索引所对应的元素。对于这里的 map，则是对应于指定键的对象。如果该map 中没有对应于指定键的对象，它将会被创建，并且赋以一个空的对象。该操作符仅对这三种容器适用。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">reference</span> <span class="nf">at</span><span class="p">(</span><span class="n">size_type</span> <span class="n">index</span><span class="p">);</span>
<span class="n">const_reference</span> <span class="n">at</span><span class="p">(</span><span class="n">size_type</span> <span class="n">index</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>at() 和数组操作符非常相似，但是有两点不同：它仅对 deque 和 vector 容器使用，并且如果所用的索引超出了容器边界，它将会抛出一个 out_of_bounds 例外。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">template</span> <span class="n">class</span><span class="o">&lt;</span><span class="n">InputIterator</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">assign</span><span class="p">(</span><span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">assign</span><span class="p">(</span><span class="n">size_type</span> <span class="n">newSize</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">from</span><span class="p">);</span>
</pre></div>
</div>
<p>assign 是一种为顺序容器所有元素一次性赋同一个值，以及实现容器拷贝的便捷方式。前一种方法从其他容器中拷贝元素，并将其拷贝到其所属容器的 first 和 last 之间，但并不覆盖 first 迭代器。后一种方法将所有容器元素设置为 from 的值。在这两种情况中，容器大小将被修改为 newSize，或者迭代器范围所指定的元素数量。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">);</span>
<span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">InputIterator</span><span class="o">&gt;</span>
<span class="kt">void</span> <span class="n">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">InputIterator</span> <span class="n">last</span><span class="p">);</span>

<span class="cm">/* 仅适用于 vector，deque，list */</span>
<span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">iterator</span> <span class="n">pos</span><span class="p">,</span> <span class="n">size_type</span> <span class="n">count</span><span class="p">,</span> <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">);</span>

<span class="cm">/* 仅适用于 map 和 set */</span>
<span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="kt">bool</span><span class="o">&gt;</span> <span class="n">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">);</span>

<span class="cm">/* 仅适用于 multimap 和 multiset */</span>
<span class="n">iterator</span> <span class="nf">insert</span><span class="p">(</span><span class="k">const</span> <span class="n">value_type</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">);</span>
</pre></div>
</div>
<p>insert() 添加元素到容器。该方法是所有的 STL 容器都通用的，尽管每个容器所使用的函数形式各异。元素插入的速度取决于容器的实现方式。例如，在 vector 容器中间添加元素比较慢，但是在其尾部添加则非常快速。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">position</span><span class="p">);</span>
<span class="n">iterator</span> <span class="nf">erase</span><span class="p">(</span><span class="n">iterator</span> <span class="n">first</span><span class="p">,</span> <span class="n">iterator</span> <span class="n">last</span><span class="p">);</span>

<span class="cm">/* 仅适用于 set，multiset，map，和 multimap */</span>
<span class="n">size_type</span> <span class="nf">erase</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">lookupValue</span><span class="p">);</span>
</pre></div>
</div>
<p>erase() 用于删除容器中的元素。和 insert() 相似，它的性能也依赖于容器的实现方式。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">swap</span><span class="p">(</span><span class="o">&lt;</span><span class="n">container</span> <span class="n">to</span> <span class="n">swap</span> <span class="n">with</span><span class="o">&gt;</span><span class="p">);</span>
</pre></div>
</div>
<p>该函数接收同样类型的容器，并交换两个容器中的元素。所有和两个容器中的元素相关的指针，引用，以及其他外部数据都保持有效。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">clear</span><span class="p">();</span>
</pre></div>
</div>
<p>一言以蔽之，该函数用以删除容器中的所有元素，即将其清空。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">push_front</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">pop_front</span><span class="p">();</span>
</pre></div>
</div>
<p>以上两个函数允许您从 deque 和 list 的头部添加或者删除元素。Pop_front() 不仅从容器中移除该元素，同时还删除钙元素。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">item</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">pop_back</span><span class="p">();</span>
</pre></div>
</div>
<p>以上两个函数和前面的 front 操作相同，但是它们在容器尾部进行改动。而且，除了 deque 和 list 可用外，还对 vector 容器可用。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">key_compare</span> <span class="n">key_comp</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>该函数返回用于比较容器中元素的对象。它可以是函数指针，实现函数调用操作符的类的实例。比较函数比较容器中两个对象的类型，如果第一个元素小于或者其在容器中处于第二个参数之前则返回真，反之则返回假。该函数仅对关联容器可用。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">value_compare</span> <span class="n">val_comp</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>该函数和 key_comp() 相似，但是它返回用以比较两个值的函数。对于 set 容器而言，它和 key_comp() 相同。该函数同样仅对关联容器可用。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">iterator</span> <span class="n">find</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">lookupValue</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>查询容器中和 lookupValue 相匹配的元素，并且返回指向该元素的迭代器，如果未找到，则返回 end()。该函数仅对关联容器可用。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">size_type</span> <span class="n">count</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">lookupValue</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>返回容器中和 lookupValue 相匹配的元素个数。尽管该方法对所有关联容器可用，但是它仅对 multiset 和 multimap 有意义，因为对于 map 和 set 所要查询的值总是唯一的。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">iterator</span> <span class="nf">lower_bound</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">lookupValue</span><span class="p">);</span>
<span class="k">const</span> <span class="n">iterator</span> <span class="n">lower_bound</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">lookupValue</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="n">iterator</span> <span class="n">upper_bound</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">lookupValue</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="n">pair</span><span class="o">&lt;</span><span class="n">iterator</span><span class="p">,</span> <span class="n">iterator</span><span class="o">&gt;</span> <span class="n">equal_range</span><span class="p">(</span><span class="k">const</span> <span class="n">key_type</span><span class="o">&amp;</span> <span class="n">lookupValue</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>lower_bound() 返回指向容器中第一个大于或者等于 lookupValue 的元素的迭代器。upper_bound() 返回指向容器中第一个大于lookupValue的元素的迭代器。equal_range() 返回两个迭代器，第一个和 lower_bound（lookupValue）相同，而第二个与 upper_bound（lookupValue）相同。和 count() 相似，以上方法均对所有的关联容器可用，但是它们仅对 multiset 和 multimap 有意义。</p>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id17">STL 和 标准库：那又怎样？</a><a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>在简短的介绍玩命名空间和模板，我们又旋风般扫过许多不同的模板类，这可能有点快了，有点难以接受。不过无须过多担心，它们并不会如您所想那般经常使用。Haiku 的 Tracker 内部有一个 BObjectList 类，其提供了 BList 类所有的易用特性，并且还能够实现内存管理。本文覆盖了索引存储的需要。map 和 multimap 容器非常适于用作随机存储容器。其他的容器则更多的用于特殊实例的引用，跨平台编程，以及其他代码的识别。在容器的嵌套中，它们也非常必要，例如 vector 的 map 容器。</p>
<p>对于 C++ 标准库，也是同样。它们中有些对于 Haiku 开发会非常方便，但是另一些可能暂时没那么有用。它们的用途部分会依赖于您在其他平台上的开发，例如 Linux 和 Windows。如果您打算只为 Haiku 编程，您可能不会经常用到标准库和 STL，但是如果您也为其他平台做开发，那么它们的使用将会使平台之间的迁移更加的容易。</p>
</div>
</div>


          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; 版权所有 2015, Haiku Chinese Group.
      最后更新于 Aug 18, 2016.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>