

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>第二十二课 &mdash; Haiku 中文文档</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Haiku 中文文档" href="../../../index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../../index.html" class="icon icon-home"> Haiku Chinese Documents
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../关于Haiku.html">关于 Haiku</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id1">Haiku 好处在哪儿？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id2">为何选择 Haiku ？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id3">谁支持着 Haiku ？</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../开发.html">开发</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id2">用户指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id3">开发文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../开发入门.html">开发入门</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id2">手册相关</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id3">入门任务</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id4">当您找到任务</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id5">编写代码准备</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#git">获取 GIT 提交权限</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id6">深入阅读</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku编程学习.html">Haiku编程学习</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id1">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id2">目录</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id3">参考资料和工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku编程教程.html">Haiku 编程详解</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程教程.html#id1">前言</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程教程.html#id2">内容概览</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku指南.html">Haiku 指南</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#guides-haiku"><code class="docutils literal"><span class="pre">/guides/构建Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id1"><code class="docutils literal"><span class="pre">/guides/安装Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id2"><code class="docutils literal"><span class="pre">/guides/启动Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#guides"><code class="docutils literal"><span class="pre">/guides/日常任务</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id3"><code class="docutils literal"><span class="pre">/guides/虚拟化</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id4">其他指南</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku源码规范.html">Haiku 编码规范</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id2">规范概况</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id3">缩进和空格</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id4">杂项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id5">标识符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id6">变量声明</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#haiku-api">使用 Haiku 内置的 API，类型等</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id7">注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id8">许可和版权</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id9">无用代码和调试代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id10">其他的要求</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id11">风格检查工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../开发常见问题（FAQ）.html">开发常见问题（FAQ）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id1">我是一个程序员，希望可以帮忙，那么从何开始呢？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id4">是否有简单的引导任务？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id6">是否有特定的编程风格？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id7">如何创建和提交补丁？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#trac">为什么无法在 Trac 中创建任务单？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id8">使用哪些开发工具？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id9">是否有开发者邮件列表？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#irc">是否有 IRC 聊天室？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id10">我尝试进行测试，但是 Haiku 编译失败。接下来该如何操作？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id11">我想把一些东西集成到官方源之中，可以集成那些组件？该使用何种协议呢？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#beos-haiku">我希望可以把我的 BeOS 程序/驱动移植到 Haiku，该如何进行？</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Haiku图标指南.html">Haiku 图标指南</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id1">透视效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id2">光源效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id3">渐变效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id4">色彩效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id5">阴影效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id6">轮廓线</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id7">高亮效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id8">使用覆盖</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id9">细节</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id10">中立图标</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id4">在线资源</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../开发.html#id7">开发工具</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../开发.html#id8">其他系统交叉编译</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../文档.html">文档</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id2">用户文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id3">开发者文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id4">早期文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../文档.html#bebook-be">BeBook 和 Be 信札</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../文档.html#id5">其他</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">Haiku Chinese Documents</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
    <li>第二十二课</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id6">第二十二课</a><a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="contents topic" id="id2">
<p class="topic-title first">内容</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id6">第二十二课</a><ul>
<li><a class="reference internal" href="#quickedit" id="id7">深入开发：QuickEdit</a></li>
<li><a class="reference internal" href="#id3" id="id8">程序架构</a><ul>
<li><a class="reference internal" href="#app-h" id="id9">App.h</a></li>
<li><a class="reference internal" href="#app-cpp" id="id10">App.cpp</a></li>
<li><a class="reference internal" href="#mainwindow-h" id="id11">MainWindow.h</a></li>
<li><a class="reference internal" href="#mainwindow-cpp" id="id12">MainWindow.cpp</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id4" id="id13">思路总结</a></li>
<li><a class="reference internal" href="#id5" id="id14">深入理解</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="quickedit">
<h2><a class="toc-backref" href="#id7">深入开发：QuickEdit</a><a class="headerlink" href="#quickedit" title="永久链接至标题">¶</a></h2>
<p>假若所有的计算机程序都如 HelloWorld 或其他演示程序那般简单！开发人员的生活就不会那般艰难。奈何，事实并不如此。在接下来的几节课中，我们将会揭去这层薄的面纱，深入其中了。为任何的操作系统设计简单的程序都会如这些程序一般琐碎，并且它们都会非常的粗糙。幸运的是，随着我们对操作系统功能的学习和了解，您将会对编写稍大型的 Haiku 程序中所涉及到的内容有所认识。</p>
<p>您可能会问，我们的项目会是什么呢？它是一个简单的格式化文本编辑器，QuickEdit。</p>
<p>尽管 Haiku 已经有了一个编辑器 StyledEdit，所以，毫无疑问，我们编写的代码将会与它有所雷同，但我们添加的功能并不一定都能够在 StyledEdit 中找到。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id8">程序架构</a><a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>如果没有了 BTextView 控件，我们的任务可就非常非常艰巨了。当然，不禁自惭，文档处理器的编写尤为不易呀。我们的程序非常简单，其蓝图如下：以 BTextView 为中心的相对简单 GUI 来构建一个简单，但是有用的文档处理器。</p>
<p>在我们轻率的写出代码之前，我们来概览一下 BTextView 类的定义，查看一下我们可以利用哪些功能，而不需要花费很多时间。这之后，会为我们省些精力和时间。需要注意的是，这些并不是这个类完整的定义，我们省却了与 QuickEdit 不相关的功能。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">BTextView</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BView</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="kt">void</span>            <span class="n">SetText</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">inText</span><span class="p">,</span> <span class="k">const</span> <span class="n">text_run_array</span><span class="o">*</span> <span class="n">inRuns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">SetText</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">inText</span><span class="p">,</span> <span class="n">int32</span> <span class="n">inLength</span><span class="p">,</span> <span class="k">const</span> <span class="n">text_run_array</span><span class="o">*</span> <span class="n">inRuns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">SetText</span><span class="p">(</span><span class="n">BFile</span><span class="o">*</span> <span class="n">inFile</span><span class="p">,</span> <span class="n">int32</span> <span class="n">startOffset</span><span class="p">,</span> <span class="n">int32</span> <span class="n">inLength</span><span class="p">,</span> <span class="k">const</span> <span class="n">text_run_array</span><span class="o">*</span>
                             <span class="n">inRuns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="kt">void</span>            <span class="nf">Insert</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">inText</span><span class="p">,</span> <span class="k">const</span> <span class="n">text_run_array</span><span class="o">*</span> <span class="n">inRuns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">Insert</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">inText</span><span class="p">,</span> <span class="n">int32</span> <span class="n">inLength</span><span class="p">,</span> <span class="k">const</span> <span class="n">text_run_array</span><span class="o">*</span> <span class="n">inRuns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">Insert</span><span class="p">(</span><span class="n">int32</span> <span class="n">startOffset</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">inText</span><span class="p">,</span> <span class="n">int32</span> <span class="n">inLength</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">text_run_array</span><span class="o">*</span> <span class="n">inRuns</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>

    <span class="kt">void</span>            <span class="nf">Delete</span><span class="p">();</span>
    <span class="kt">void</span>            <span class="nf">Delete</span><span class="p">(</span><span class="n">int32</span> <span class="n">startOffset</span><span class="p">,</span> <span class="n">int32</span> <span class="n">endOffset</span><span class="p">);</span>
    <span class="k">const</span> <span class="kt">char</span><span class="o">*</span>     <span class="n">Test</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">int32</span>           <span class="n">TestLength</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span>            <span class="n">GetText</span><span class="p">(</span><span class="n">int32</span> <span class="n">offset</span><span class="p">,</span> <span class="n">int32</span> <span class="n">length</span><span class="p">,</span> <span class="kt">char</span><span class="o">*</span> <span class="n">buffer</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">uint8</span>           <span class="n">ByteAt</span><span class="p">(</span><span class="n">int32</span> <span class="n">offset</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">int32</span>           <span class="n">CountLines</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="n">int32</span>           <span class="n">CurrentLine</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span>            <span class="nf">GoToLine</span><span class="p">(</span><span class="n">int32</span> <span class="n">lineIndex</span><span class="p">);</span>

    <span class="kt">void</span>            <span class="nf">Cut</span><span class="p">(</span><span class="n">BClipboard</span><span class="o">*</span> <span class="n">clipboard</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">Copy</span><span class="p">(</span><span class="n">BClipboard</span><span class="o">*</span> <span class="n">clipboard</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">Paste</span><span class="p">(</span><span class="n">BClipboard</span><span class="o">*</span> <span class="n">clipboard</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">Clear</span><span class="p">();</span>

    <span class="kt">bool</span>            <span class="nf">AcceptsPaste</span><span class="p">(</span><span class="n">BClipboard</span><span class="o">*</span> <span class="n">clipboard</span><span class="p">);</span>
    <span class="kt">bool</span>            <span class="nf">AcceptsDrop</span><span class="p">(</span><span class="k">const</span> <span class="n">BMessage</span><span class="o">*</span> <span class="n">inMessage</span><span class="p">);</span>

    <span class="kt">void</span>            <span class="nf">Select</span><span class="p">(</span><span class="n">int32</span> <span class="n">startOffset</span><span class="p">,</span> <span class="n">int32</span> <span class="n">endOffset</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">SelectAll</span><span class="p">();</span>
    <span class="kt">void</span>            <span class="n">GetSelection</span><span class="p">(</span><span class="n">int32</span><span class="o">*</span> <span class="n">outStart</span><span class="p">,</span> <span class="n">int32</span><span class="o">*</span> <span class="n">outEnd</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>            <span class="nf">SetFontAndColor</span><span class="p">(</span><span class="k">const</span> <span class="n">BFont</span><span class="o">*</span> <span class="n">inFont</span><span class="p">,</span> <span class="n">uint32</span> <span class="n">inMode</span> <span class="o">=</span> <span class="n">B_FONT_ALL</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">rgb_color</span><span class="o">*</span> <span class="n">inColor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">SetFontAndColor</span><span class="p">(</span><span class="n">int32</span> <span class="n">startOffset</span><span class="p">,</span> <span class="n">int32</span> <span class="n">endOffset</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">BFont</span><span class="o">*</span> <span class="n">inFont</span><span class="p">,</span> <span class="n">uint32</span> <span class="n">inMode</span> <span class="o">=</span> <span class="n">B_FONT_ALL</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">rgb_color</span><span class="o">*</span> <span class="n">inColor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="n">GetFontAndColor</span><span class="p">(</span><span class="n">int32</span> <span class="n">inOffset</span><span class="p">,</span> <span class="n">BFont</span><span class="o">*</span> <span class="n">outFont</span><span class="p">,</span>
                            <span class="n">rgb_color</span><span class="o">*</span> <span class="n">outColor</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span>            <span class="nf">FindWord</span><span class="p">(</span><span class="n">int32</span> <span class="n">inOffset</span><span class="p">,</span> <span class="n">int32</span><span class="o">*</span> <span class="n">outFromOffset</span><span class="p">,</span>
                            <span class="n">int32</span><span class="o">*</span> <span class="n">outToOffset</span><span class="p">);</span>
    <span class="kt">float</span>           <span class="n">LineWidth</span><span class="p">(</span><span class="n">int32</span> <span class="n">lineIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="n">cosnt</span><span class="p">;</span>
    <span class="kt">float</span>           <span class="n">LineHeight</span><span class="p">(</span><span class="n">int32</span> <span class="n">lineIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">float</span>           <span class="n">TextHeight</span><span class="p">(</span><span class="n">int32</span> <span class="n">startLine</span><span class="p">,</span> <span class="n">int32</span> <span class="n">endLine</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>            <span class="nf">ScrollToOffset</span><span class="p">(</span><span class="n">int32</span> <span class="n">inOffset</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">ScrollToSelection</span><span class="p">();</span>

    <span class="kt">void</span>            <span class="nf">Highlight</span><span class="p">(</span><span class="n">int32</span><span class="p">,</span> <span class="n">startOffset</span><span class="p">,</span> <span class="n">int32</span> <span class="n">endOffset</span><span class="p">);</span>

    <span class="kt">void</span>            <span class="nf">SetTextRect</span><span class="p">(</span><span class="n">BRect</span> <span class="n">rect</span><span class="p">);</span>
    <span class="n">BRect</span>           <span class="n">TextRect</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">void</span>            <span class="nf">SetInsets</span><span class="p">(</span><span class="kt">float</span> <span class="n">left</span><span class="p">,</span> <span class="kt">float</span> <span class="n">top</span><span class="p">,</span> <span class="kt">float</span> <span class="n">right</span><span class="p">,</span> <span class="kt">float</span> <span class="n">bottom</span><span class="p">);</span>

    <span class="kt">void</span>            <span class="n">GetInsets</span><span class="p">(</span><span class="kt">float</span><span class="o">*</span> <span class="n">_left</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">_top</span><span class="p">,</span>
                        <span class="kt">float</span><span class="o">*</span> <span class="n">_right</span><span class="p">,</span> <span class="kt">float</span><span class="o">*</span> <span class="n">_bottom</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>            <span class="nf">SetStylable</span><span class="p">(</span><span class="kt">bool</span> <span class="n">stylable</span><span class="p">);</span>
    <span class="kt">bool</span>            <span class="n">IsStylable</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>            <span class="nf">SetTabWidth</span><span class="p">(</span><span class="kt">float</span> <span class="n">width</span><span class="p">);</span>
    <span class="kt">float</span>           <span class="n">TabWidth</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>            <span class="nf">SetWordWrap</span><span class="p">(</span><span class="kt">bool</span> <span class="n">wrap</span><span class="p">);</span>
    <span class="kt">bool</span>            <span class="n">DoesWordWrap</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>            <span class="nf">SetMaxBytes</span><span class="p">(</span><span class="n">int32</span> <span class="n">max</span><span class="p">);</span>
    <span class="n">int32</span>           <span class="n">MaxBytes</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>            <span class="nf">DisallowChar</span><span class="p">(</span><span class="n">uint32</span> <span class="n">aChar</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">AllowChar</span><span class="p">(</span><span class="n">uint32</span> <span class="n">aChar</span><span class="p">);</span>

    <span class="kt">void</span>            <span class="nf">SetAlignment</span><span class="p">(</span><span class="n">alignment</span> <span class="n">flag</span><span class="p">);</span>
    <span class="n">alignment</span>       <span class="n">Alignment</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>            <span class="nf">SetAutoindent</span><span class="p">(</span><span class="kt">bool</span> <span class="n">state</span><span class="p">);</span>
    <span class="kt">bool</span>            <span class="n">DoesAutoindent</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>            <span class="nf">SetColorSpace</span><span class="p">(</span><span class="n">color_space</span> <span class="n">colors</span><span class="p">);</span>
    <span class="n">color_space</span>     <span class="n">ColorSpace</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>            <span class="nf">MakeResizable</span><span class="p">(</span><span class="kt">bool</span> <span class="n">resize</span><span class="p">,</span> <span class="n">BView</span><span class="o">*</span> <span class="n">resizeView</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>
    <span class="kt">bool</span>            <span class="n">IsResizable</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>            <span class="nf">SetDoesUndo</span><span class="p">(</span><span class="kt">bool</span> <span class="n">undo</span><span class="p">);</span>
    <span class="kt">bool</span>            <span class="n">DoesUndo</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>            <span class="nf">HideTyping</span><span class="p">(</span><span class="kt">bool</span> <span class="n">enabled</span><span class="p">);</span>
    <span class="kt">bool</span>            <span class="n">IsTypingHidden</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

    <span class="kt">void</span>            <span class="nf">Undo</span><span class="p">(</span><span class="n">Clipboard</span><span class="o">*</span> <span class="n">clipboard</span><span class="p">);</span>
    <span class="n">undo_state</span>      <span class="n">UndoState</span><span class="p">(</span><span class="kt">bool</span><span class="o">*</span> <span class="n">isRedo</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>看看这些方法，它们为我们提供了非常有趣的功能。我们可以提供撤销和在窗口锁定文字等选项。制表键所占据的空间宽度也可以通过小控件进行修改，我们也可以使用文本矩形框特性来作为页面边角设置等功能。字体颜色和样式也可以进行设置，并且我们还有一些其他的字体效果并未列出，如下划线，粗体和斜体样式，轮廓等等。也可以执行剪贴板操作。还有一些基本的对齐操作支持，尽管在常规的字处理程序中，它并不常用。</p>
<p>尽管有这么多的功能，我们还是从简入手。如果我们尽量遵循基本字处理程序常用的工作流程，那么从这里开始和构建将会比事先确定所有内容要更为容易。</p>
<p>在编写字处理程序最初阶段，我们的目标将是我们早已熟知的内容：一个带有文本编辑器的窗口，可用于保存和载入文本。在 Paladin 中利用 Main Window with Menu 模板新建一个项目。在 App.cpp 中修改程序署名为 “application/x-vnd.dw-QuickEdit”，使用您自己的初始化内容取代原作者的程序，然后保存您的修改。您需要进入 Project 菜单中的 Change System Libraries 菜单，然后添加 libtracker.so 和 libtranslation.so 库。App.h 和 App.cpp 如下所示：</p>
<div class="section" id="app-h">
<h3><a class="toc-backref" href="#id9">App.h</a><a class="headerlink" href="#app-h" title="永久链接至标题">¶</a></h3>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#ifndef APP_H</span>
<span class="cp">#define APP_H</span>

<span class="cp">#include &lt;Application.h&gt;</span>

<span class="k">class</span> <span class="nc">App</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BApplication</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
    <span class="n">App</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></div>
</div>
</div>
<div class="section" id="app-cpp">
<h3><a class="toc-backref" href="#id10">App.cpp</a><a class="headerlink" href="#app-cpp" title="永久链接至标题">¶</a></h3>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &quot;App.h&quot;</span>
<span class="cp">#include &quot;MainWindow.h&quot;</span>

<span class="n">App</span><span class="o">::</span><span class="n">App</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="o">:</span>   <span class="n">BApplication</span><span class="p">(</span><span class="s">&quot;application/x-vnd.dw-QuickEdit&quot;</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MainWindow</span><span class="o">*</span> <span class="n">mainwin</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MainWindow</span><span class="p">();</span>
    <span class="n">mianwin</span><span class="o">-&gt;</span><span class="n">Show</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">App</span> <span class="o">*</span><span class="n">app</span> <span class="o">=</span> <span class="k">new</span> <span class="n">App</span><span class="p">();</span>
    <span class="n">app</span><span class="o">-&gt;</span><span class="n">Run</span><span class="p">();</span>
    <span class="k">delete</span> <span class="n">app</span><span class="p">;</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>以上这些代码目前都没什么特别的意义。我们的重点在于 MainWindow.h 和 MainWindow.cpp。</p>
</div>
<div class="section" id="mainwindow-h">
<h3><a class="toc-backref" href="#id11">MainWindow.h</a><a class="headerlink" href="#mainwindow-h" title="永久链接至标题">¶</a></h3>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#ifndef MAINWINDOW_H</span>
<span class="cp">#define MAINWINDOW_H</span>

<span class="cp">#include &lt;Window.h&gt;</span>
<span class="cp">#include &lt;Entry.h&gt;</span>
<span class="cp">#include &lt;FilePanel.h&gt;</span>
<span class="cp">#include &lt;MenuBar.h&gt;</span>
<span class="cp">#include &lt;String.h&gt;</span>
<span class="cp">#include &lt;TextView.h&gt;</span>

<span class="k">class</span> <span class="nc">MainWindow</span> <span class="o">:</span> <span class="k">public</span> <span class="n">BWindow</span>
<span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
                    <span class="n">MainWindow</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
                    <span class="o">~</span><span class="n">MainWindow</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">MessageReceived</span><span class="p">(</span><span class="n">BMessage</span><span class="o">*</span> <span class="n">msg</span><span class="p">);</span>
    <span class="kt">bool</span>            <span class="nf">QuitRequested</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">OpenFile</span><span class="p">(</span><span class="k">const</span> <span class="n">entry_ref</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">SaveFile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">path</span><span class="p">);</span>
    <span class="kt">void</span>            <span class="nf">FrameResized</span><span class="p">(</span><span class="kt">float</span> <span class="n">w</span><span class="p">,</span> <span class="kt">float</span> <span class="n">h</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span>            <span class="n">UpdateTextRect</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>

    <span class="n">BMenuBar</span><span class="o">*</span>       <span class="n">fMenuBar</span><span class="p">;</span>
    <span class="n">BTextView</span><span class="o">*</span>      <span class="n">fTextView</span><span class="p">;</span>
    <span class="n">BFilePanel</span><span class="o">*</span>     <span class="n">fOpenPanel</span><span class="p">;</span>
    <span class="n">BFilePanel</span><span class="o">*</span>     <span class="n">fSavePanel</span><span class="p">;</span>

    <span class="n">BString</span>         <span class="n">fFilePath</span><span class="p">;</span>
<span class="p">};</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p>在上述头文件中，我们新碰到的是用于在载入和保存文件的 BFilePanel 类，以及提供了所有我们需要的文本编辑服务的 BTextView 类。</p>
</div>
<div class="section" id="mainwindow-cpp">
<h3><a class="toc-backref" href="#id12">MainWindow.cpp</a><a class="headerlink" href="#mainwindow-cpp" title="永久链接至标题">¶</a></h3>
<div class="highlight-cpp"><div class="highlight"><pre>#include &quot;MainWindow.h&quot;

#include &lt;Alert.h&gt;
#include &lt;Application.h&gt;
#include &lt;Directory.h&gt;
#include &lt;File.h&gt;
#include &lt;Menu.h&gt;
#include &lt;MenuItem.h&gt;
#include &lt;Messenger.h&gt;
#include &lt;NodeInfo.h&gt;
#include &lt;Path.h&gt;
#include &lt;ScrollView.h&gt;
#include &lt;String.h&gt;
#include &lt;TranslationUtils.h&gt;

enum
{
    M_FILE_VIEW = &#39;flnw&#39;,
    M_SHOW_OPEN = &#39;shop&#39;,
    M_SAVE = &#39;save&#39;,
    M_SAVE_AS = &#39;svas&#39;,
    M_PRINT_SETUP = &#39;ptcf&#39;,
    M_PRINT = &#39;prin&#39;
};

MainWindow::MainWindow(void)
    :   BWindow(BRect(100,100,500,400), &quot;QuickEdit&quot;, B_TITLED_WINDOW,
                 B_ASYNCHRONOUS_CONTROLS)
{
        // 我们首先创建一个菜单栏，并且使用我们将要实现的命令来填充该菜单。
        BRect(Bounds());
        r.bottom = 20;
        fMenuBar = new BMenuBar(r, &quot;menubar&quot;);
        AddChild(fMenuBar);
        BMenu* menu = new BMenu(&quot;File&quot;);
        fMenuBar-&gt;AddItem(menu);

        // 下面是添加菜单项的快捷方式。需要注意的是
        // 快捷键是 Haiku 标准：
        //          Alt + N =&gt; New file
        //          Alt + O =&gt; Open file
        //          Alt + S =&gt; Save file
        //          Alt + Shift + S =&gt; Save As

        // 快捷键通常和Alt按键成对执行只是习惯如此，
        // 也可以如 Windows 和 Linux 一样使用 Ctrl
        // 按键作为命令键。
        menu-&gt;AddItem(new BMenuItem(&quot;New&quot;, new BMessage(M_FILE_NEW), &#39;N&#39;));
        menu-&gt;AddItem(new BMenuItem(&quot;Open&quot;, new BMessage(M_SHOW_OPEN), &#39;O&#39;));
        menu-&gt;AddSeparatorItem();
        menu-&gt;AddItem(new BMenuItem(&quot;Save&quot;, new BMessage(M_SAVE), &#39;S&#39;));

        // 下面的函数，跟上述其他不同，其指明了使用多于Alt加上单个字
        // 符的快捷键。
        menu-&gt;AddItem(new BMenuItem(&quot;Save As&quot;, B_UTF8_ELLIPSIS,
                        new BMessage(M_SAVE_AS), &#39;S&#39;,
                        B_COMMAND_KEY | B_SHIFT_KEY));

        // 接下来，我们将添加文本视图和滚动栏。为了方便，我们将使用
        // BScrollView。在使用BScrollView时，首先需要创建其目标对象，
        // 然后创建BScrollView，最后调用仅适用于BScrollView的AddChild
        // 方法，它将会完成添加其目标对象的操作。
        r = Bounds();
        r.top = fMenuBar-&gt;Frame().bottom + 1;

        // 在计算目标视图的区域大小时，您必须为BScrollView提供的滚动栏
        // 预先留足额外的宽和高。Haiku为我们提供了用于此的B_V_SCROLL_BAR_WIDTH
        // B_H_SCROLL_BAR_WIDTH常量。
        r.right -= B_V_SCROLL_BAR_WIDTH;

        // 我们将要用到的BTextView构造函数不仅需要一个框架大小，还需要
        // 用于文本现实的矩形区域。可以对其或多或少的加以设置。
        BRect textRect = r;
        textRect.OffsetTo(0,0);
        textRect.InsetBy(5,5);
        fTextView = new BTextView(r, &quot;textview&quot;, textRect, B_FOLLOW_ALL);

        // 没有下面的调用，我们的BTextView仅仅是一个纯文本编辑器
        fTextView-&gt;SetStylable(true);

        BScrollView* scrollView = new BScrollView(&quot;scrollview&quot;, fTextView,
                                        B_FOLLOW_ALL, 0, false, true);
        AddChild(scrollView);

        // 下面我们将使用一个新类：BFilePanel。更多使用稍后再述。
        BMessenger msgr(NULL, this);
        fOpenPanel = new BFilePanel(B_OPEN_PANEL, &amp;msgr, NULL, 0, false);
        fSavePanel = new BFilePanel(B_SAVE_PANEL, &amp;msgr, NULL, 0, false);

        // 下面的代码能够让用户在程序运行时马上可以进行输入。如果
        // 没有该调用，用户必须手动点击窗口以便输入。这相当的犯人！
        fTextView-&gt;MakeFocus(true);
}

MainWindow::~MainWindow(void)
{
        delete fOpenPanel;
        delete fSavePanel;
}

void
MainWindow::MessageReceived(BMessage* msg)
{
    switch (msg-&gt;what)
    {
    case M_FILE_NEW:
    {
        // 清空BTextView中的所有文本。并且将文件路径
        // 置为空以表明文件未被保存到磁盘。
        fTextView-&gt;SetText(&quot;&quot;);
        fFilePath = &quot;&quot;;
        break;
    }
    // 下述是与文件的打开和保存相关的case语句
    case M_SHOW_OPEN:
    {
        fOpenPanel-&gt;Show();
        break;
    }
    case B_REFS_RECEIVED:
    {
        entry_ref ref;
        if (msg-&gt;FindRef(&quot;ref&quot;, &amp;ref) != B_OK)
            break;
        OpenFile(ref);
        break;
    }
    case M_SAVE:
    {
        if (fFilePath.CountChars() &lt; 1)
            fSavePanel-&gt;Show();
        else
            SaveFile(fFilePath.String());
        break;
    }
    case M_SAVE_AS:
    {
        fSavePanel-&gt;Show();
        break;
    }
    case B_SAVE_REQUESTED:
    {
        entry_ref dir;
        BString name;
        if (msg-&gt;FindRef(&quot;directory&quot;, &amp;dir) == B_OK &amp;&amp;
                msg-&gt;FindString(&quot;name&quot;, &amp;name) == B_OK)
        {
            BPath path(&amp;dir);
            path.Append(name);
            SaveFile(path.Path());
        }
        break;
    }
    default:
    {
        BWindow::MessageReceived(msg);
        break;
    }
    }
}

bool
MainWindow::QuitRequested(void)
{
    be_app-&gt;PostMessage(B_QUITE_REQUESTED);
    return true;
}

void
MainWindow::OpenFile(const entry_ref&amp; ref)
{
    // 将符号链接转换为其目标对象
    BEntry entry(&amp;ref, true);
    entry_ref realRef;
    entry.GetRef(&amp;realRef);

    // Translation套件提供了文本文件的翻译服务。
    BFile file(&amp;realRef, B_READ_ONLY);
    if (file.InitCheck() != B_OK)
        return;

    // 一个从文件中读取格式化文本的简单函数。Nice!
    if (BTranslationUtils::GetStyledText(&amp;file, fTextView) == B_OK)
    {
        // BPath 是Storage套件中使用数据类和常规字符串
        // 路径之间转换的桥梁。下面我们设置BPath实例为
        // 打开文件的绝对路径，并且将窗口的标题设置为文件名。
        BPath path(&amp;realRef);
        fFilePath = path.Path();
        SetTitle(path.Leaf());
    }
}

void
MainWindow::SaveFile(const char* path)
{
    // 该函数接收一个字符串路径，然后保存BTextView中的数据到
    // 路径所指的文件，如果文件不存在则创建该文件，否则则覆盖
    // 已存在的文件。
    BFile file;
    if (file.SetTo(path, B_READ_WRITE | B_CREATE_FILE | B_ERASE_FILE)
            != B_OK)
        return;

    if (BTranslationUtils::PutStyledText(fTextView, &amp;file) == B_OK)
    {
        fFilePath = path;

        BNodeInfo nodeInfo(&amp;file);
        nodeInfo.SetType(&quot;text/plain&quot;);
    }
}

void
MainWindow::FrameResized(float w, float h)
{
    // 下面是一些需要铭记的箴言：在BTextView缩放时，
    // 它并不会更新他的文本框区域。在窗口缩放时，
    // 我们的TextView将也会进行缩放。FrameResized()
    // 将确保文本框的更新。
    UpdateTextRect();
}

void
MainWindow::UpdateTextRect(void)
{
    BRect r(fRectView-&gt;Bounds());
    r.InsetBy(5,5);
    fTextView-&gt;SetTextRect(r);
}
</pre></div>
</div>
<p>在上面这段代码中，我们有两点需要重申。第一点是 GetStyledText() 和 PutStyledText() 调用。Translation 套件已经为我们提供了保存格式化文本的工具！我们编程技巧的第二点就是工具包，也就是对 BFilePanel 的使用。</p>
<p>BFilePanel 是一个高度定制的文件和目录选择类。尽管它属于 Storage 套件的一部分，它也被认为是 Interface 套件的一部分。在构造之后，您只需要调用它的 Show() 方法以便让用户选择文件即可。我们在 MainWindow 构造函数中还看到了一下三行代码：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">BMessenger</span> <span class="nf">msgr</span><span class="p">(</span><span class="nb">NULL</span><span class="p">,</span> <span class="k">this</span><span class="p">);</span>
<span class="n">fOpenPanel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BFilePanel</span><span class="p">(</span><span class="n">B_OPEN_PANEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msgr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
<span class="n">fSavePanel</span> <span class="o">=</span> <span class="k">new</span> <span class="n">BFilePanel</span><span class="p">(</span><span class="n">B_SAVE_PANEL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">msgr</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>它们分别用于创建打开和保存面板，但是这些调用中的参数并未告诉我们它们究竟如何运行。下面是 BFilePanel 构造函数的声明：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">BFilePanel</span><span class="p">(</span><span class="n">file_panel_mode</span> <span class="n">panelMode</span> <span class="o">=</span> <span class="n">B_OPEN_PANEL</span><span class="p">,</span>
    <span class="n">BMessenger</span><span class="o">*</span> <span class="n">target</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">entry_ref</span><span class="o">*</span> <span class="n">panelDirectory</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="n">uint32</span> <span class="n">nodeTypes</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">allowMultiple</span> <span class="o">=</span> <span class="nb">true</span><span class="p">,</span>
    <span class="n">BMessage</span><span class="o">*</span> <span class="n">msg</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span> <span class="n">BRefFilter</span><span class="o">*</span> <span class="n">refFilter</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">,</span>
    <span class="kt">bool</span> <span class="n">modal</span> <span class="o">=</span> <span class="nb">false</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">hide_when_done</span> <span class="o">=</span> <span class="nb">true</span><span class="p">);</span>
</pre></div>
</div>
<p>该构造函数为提供了很多参数，并且为每个参数都提供了默认值。panelMode 可以设置为 B_OPEN_PANEL 或者 B_SAVE_PANEL。如果设置，它也可以进行修改。由于这两个模式在行为上具有微小但重要的不同，因此我们在该实例中需要两种不同模式的面板。target 是面板发送的保存或打开消息的接收方。默认的对象是 be_app_messenger，也就是指向每个程序所使用的 BApplication 实例的 BMessenger 对象。我们已经修改了该面板，使其指向我们的窗口。panelDirectory 可以是文件系统中的任何目录，但是其默认为用户的 home 文件夹。allowMultiple 决定了是否可以选择多个文件入口。msg 是做出选择时面板发送的消息。我们过会儿再分析 msg 的默认情况。refFilter 是一个 BRefFilter 对象，其可以用于仅显示指定文件类型的文件。modal 可以使面板的窗口需要一次按钮的点击；只在很少的情况下才需要。除非真的有合理的理由，否则不要启用面板的 modal 参数。最后，如果 hide_when_done 设置为 false，那么面板将会保持打开，即使用户已经做了选择，该选项也极少用到。</p>
<p>我们需要更近一步的介绍一下 nodeTypes 参数。其值由一个或之多三个标记设置，B_FILE_NODE，B_DIRECTORY_NODE，和 B_SYMLINK_NODE。默认情况下，B_FILE_NODE，允许选中文件和任何指向文件的符号链接。同时使用 B_FILE_NODE 和 B_DIRECTORY_NODE 则允许用户选择目录和指向目录的符号链接。在这两种情况下，在面板中双击目录，面板将会进入该目录，但并不会进行选中。B_SYMLINK 总是单独使用，并且很少使用：如果单独使用，它仅允许选中符号链接。</p>
<p>在用户做出选择时，所发送的消息取决于所作的选择和面板的模式。如果未作定义，打开面板将会发送 B_REFS_RECEIVED 消息，而保存面板将会发送 B_SAVE_REQUESTED 消息。自定义消息具有和构造函数或者 SetMessage() 调用所设置的相同的 what 字段。它也可以在设置时添加附加数据，即拷贝您原本的消息，添加标准打开和保存字段，然后发送消息到指定目标。</p>
<p>打开通知将发送消息 refs 字段中保存的一系列 entry_ref 对象发送到目标对象。需要注意的是，它们是用户选中的内容。尽管您必须解析所有的符号链接，但这些都微不足道：利用 entry_ref 创建 BEnry，并将第二个参数设为 true。如果您需要新建一个 entry_ref，调用 BEntry 的 GetRef() 方法创建即可。您可以参照上述的 MainWindow::OpenFile()中的代码作为示例。</p>
<p>保存通知包含两个额外的字段：命名为 directory 的 entry_ref 对象和命名为 name 的字符串。您可以使用这两个字段和 BPath 实例构造文件的完整路径。我们在 MessageReceived() 函数中使用了这种方法。当然，您也可以传递 BDirectory 实例的引用，然后调用 CreateFile()。需要注意的是，如果文件可能已经存在，用户需要确认覆盖文件。在这种情况下，您只需要将文件删除。我们可以在 SaveFile() 中使用 B_CREATE_FILE 和 B_ERASE_FILE 标志进行处理，这样可以确保，如果文件不存在则进行创建，反之则将其覆盖。</p>
</div>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id13">思路总结</a><a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>如果您并未进行过任何大的编程项目，而只是做过一些简单的小应用，那么本节课中的代码可能会有点冗长。大型程序，例如字处理程序都是非常大的项目。但是，这些程序通常都是从小的部分开始的，就像上述我们所编写的程序，然后慢慢增长。如果我们做一个规划和设计方案，那么 QuickEdit 对我们来说将不难理解。</p>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id14">深入理解</a><a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>思考一下，您自己是否有一些希望实现的功能。</li>
<li>试着思考一下，如何将本节课中所讨论的功能整合到程序中。</li>
</ul>
</div>
</div>


          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; 版权所有 2015, Haiku Chinese Group.
      最后更新于 Aug 18, 2016.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>