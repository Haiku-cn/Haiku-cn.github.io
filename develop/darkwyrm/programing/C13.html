

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>第十三课 &mdash; Haiku 中文文档</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Haiku 中文文档" href="../../../index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../../index.html" class="icon icon-home"> Haiku Chinese Documents
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../关于Haiku.html">关于 Haiku</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id1">Haiku 好处在哪儿？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id2">为何选择 Haiku ？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id3">谁支持着 Haiku ？</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../开发.html">开发</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id2">用户指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id3">开发文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../开发入门.html">开发入门</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id2">手册相关</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id3">入门任务</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id4">当您找到任务</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id5">编写代码准备</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#git">获取 GIT 提交权限</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id7">深入阅读</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku编程学习.html">Haiku编程学习</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id1">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id2">目录</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id3">参考资料和工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku编程教程.html">Haiku 编程详解</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程教程.html#id1">前言</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程教程.html#id2">内容概览</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku指南.html">Haiku 指南</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#guides-haiku"><code class="docutils literal"><span class="pre">/guides/构建Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id1"><code class="docutils literal"><span class="pre">/guides/安装Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id2"><code class="docutils literal"><span class="pre">/guides/启动Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#guides"><code class="docutils literal"><span class="pre">/guides/日常任务</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id3"><code class="docutils literal"><span class="pre">/guides/虚拟化</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id4">其他指南</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku源码规范.html">Haiku 编码规范</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id2">规范概况</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id3">缩进和空格</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id4">杂项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id5">标识符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id6">变量声明</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#haiku-api">使用 Haiku 内置的 API，类型等</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id7">注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id8">许可和版权</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id9">无用代码和调试代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id10">其他的要求</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id11">风格检查工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../开发常见问题（FAQ）.html">开发常见问题（FAQ）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id1">我是一个程序员，希望可以帮忙，那么从何开始呢？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id4">是否有简单的引导任务？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id6">是否有特定的编程风格？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id7">如何创建和提交补丁？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#trac">为什么无法在 Trac 中创建任务单？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id8">使用哪些开发工具？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id9">是否有开发者邮件列表？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#irc">是否有 IRC 聊天室？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id10">我尝试进行测试，但是 Haiku 编译失败。接下来该如何操作？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id11">我想把一些东西集成到官方源之中，可以集成那些组件？该使用何种协议呢？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#beos-haiku">我希望可以把我的 BeOS 程序/驱动移植到 Haiku，该如何进行？</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Haiku图标指南.html">Haiku 图标指南</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id1">透视效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id2">光源效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id3">渐变效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id4">色彩效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id5">阴影效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id6">轮廓线</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id7">高亮效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id8">使用覆盖</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id9">细节</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id10">中立图标</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id4">在线资源</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../开发.html#id7">开发工具</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../开发.html#id8">其他系统交叉编译</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../文档.html">文档</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id2">用户文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id3">开发者文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id4">早期文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../文档.html#bebook-be">BeBook 和 Be 信札</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../文档.html#id5">其他</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">Haiku Chinese Documents</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
    <li>第十三课</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id8">第十三课</a><a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="contents topic" id="id2">
<p class="topic-title first">内容</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id8">第十三课</a><ul>
<li><a class="reference internal" href="#id3" id="id9">查询</a></li>
<li><a class="reference internal" href="#id4" id="id10">查询语法</a></li>
<li><a class="reference internal" href="#bquery" id="id11">使用BQuery</a></li>
<li><a class="reference internal" href="#id5" id="id12">使用实时搜索</a></li>
<li><a class="reference internal" href="#id6" id="id13">总结</a></li>
<li><a class="reference internal" href="#id7" id="id14">深入思考</a></li>
</ul>
</li>
</ul>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id9">查询</a><a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>Haiku的原操作系统，BeOS，领先于时代，引入了超前于 windows95 和 MacOS 等那个时代相互竞争的操作系统的先进特性。除了扩展文件属性，它还提供了查询支持。查询是轻量快速的文件搜索，需要借助 Haiku 特别的文件系统：BFS。BeOS 用户曾经使用查询来组织 MP3，联系人，电子邮件，和图片，然而其他的操作系统则需要递归的搜索每个文件来匹配相应的文件名及其他类似内容。Haiku 用户仍然执行所有这些，但是除了高级用户和开发者，通常它并没有得到充分的应用。甚至现在，使用同样的动力，在不触及操作系统其他部分的前提下，许多有名的操作系统并不能够快速和简单的搜索文件。</p>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id10">查询语法</a><a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>查询通常通过 Tracker 的 Find 窗口来运行。它们通常使用 by name 和 by attribute 模式。资深的 Haiku 用户喜欢使用 by formula（使用表达式）设置，它使用文件系统查询的实际语法而不拘泥细节。幸运的是，查询的语法相对简单，而且通过在其他模式中输入测试查询可以快速的进行学习，然后在使用表达式模式。</p>
<p>那么我们以一个简单的查询开始：查找所有的新邮件。</p>
<ol class="arabic simple">
<li>按下 <cite>Ctrl-F</cite> 打开 Tracker 的 Find 窗口或者在 Deskbar 或者 Tracker 窗口的 File 菜单中选择 Find…。</li>
<li>在text子菜单中修改文件类型为 E-mail，而不是保留其设置为 All files and folders。</li>
<li>修改 by name 模式为 by attribute。</li>
<li>接下来，点击标记为 Name 的菜单栏，从 Status 子菜单中选中 is，然后在文本框中输入 new。这将是查询将要搜索的内容，但是通过改变模式为 by formula 来查看查询的真正语法。</li>
</ol>
<p>完成所有这些之后，您将会在 Find 窗口中看到下面的内容：</p>
<div class="highlight-none"><div class="highlight"><pre>((MAIL: status==”[nN] [eE] [wW]”)&amp;&amp;(BEOS:TYPE==”text/x-email”))
</pre></div>
</div>
<p>对于那些不熟悉正则表达式的用户，带有中括号的一组字符用于匹配该组的单个字符。例如，<cite>[nN]</cite> 用于匹配字符 N，同时忽略大小写。本次查询将会匹配任何状态属性为 new 的电子邮件，而不会注意大小写的情况。查询是大小写敏感的，但是任何以名字或者属性模式创建的查询会进行转换，所以它们不是大小写敏感的。</p>
<p>查询可以非常的复杂，但是它们不是必须那样的。一个比较简单的查询也可以完成上述的任务：</p>
<div class="highlight-none"><div class="highlight"><pre>MAIL:status==”[nN]ew”
</pre></div>
</div>
<p>由于 e-mail 文件仅仅具有 MAIL:status 属性，因此只进行属性的搜索可能会更好。</p>
<p>如果一个关于某个属性的查询被执行，那么它必须被索引。终端命令 lsindex、rmindex、和 mkindex 用于操作和列出那些被索引的属性。需要注意的是，当使用 mkindex 命令将一个属性添加到文件系统的索引时，所有具有该属性的文件不会被查询自动检出。它们必须重新进行索引。这可以通过拷贝文件到其他地方，然后在将其拷贝回去，或者使用 reindex 终端命令来完成。对于这个小技巧，提醒一句：不要害怕添加一个属性到索引。但是也不要随意的添加。添加太多的属性将会减慢所有基于查询的搜索的性能。</p>
</div>
<div class="section" id="bquery">
<h2><a class="toc-backref" href="#id11">使用BQuery</a><a class="headerlink" href="#bquery" title="永久链接至标题">¶</a></h2>
<p>使用 BQuery 来执行查询可以有两种方法。如果您了解确切的查询语法，那么简单的方法将会非常容易。另一种较为复杂的方法可能更加灵活，但是在多数情况下不是必须的。首先，我们来学习较简单的方法。下面是在引导分区执行查询的一些非常基本的代码：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;Query.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;String.h&gt;</span>
<span class="cp">#include &lt;VolumeRoster.h&gt;</span>
<span class="cp">#include &lt;Volume.h&gt;</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get a BVolume object which represents the boot volume. A BQuery</span>
    <span class="c1">// object will require one.</span>
    <span class="n">BVolumeRoster</span> <span class="n">volRoster</span><span class="p">;</span>
    <span class="n">BVolume</span> <span class="n">bootVolume</span><span class="p">;</span>
    <span class="n">volRoster</span><span class="p">.</span><span class="n">GetBootVolume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bootVolume</span><span class="p">);</span>

    <span class="c1">// A quick summary for using BQuery:</span>
    <span class="c1">// 1) Make the BQuery object.</span>
    <span class="c1">// 2) Set the target volume with SetVolume().</span>
    <span class="c1">// 3) Specify the search terms with SetPredicate().</span>
    <span class="c1">// 4) Call Fetch() to start the search</span>
    <span class="c1">// 5) Iterate over the results list using GetNextEntry(),</span>
    <span class="c1">//GetNextRef(), or GetNextDirents(),</span>

    <span class="n">BString</span> <span class="n">predicate</span><span class="p">(</span><span class="s">&quot;MAIL:subject == *&quot;</span><span class="p">);</span>
    <span class="n">BQuery</span> <span class="n">query</span><span class="p">;</span>
    <span class="n">query</span><span class="p">.</span><span class="n">SetVolume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bootVolume</span><span class="p">);</span>
    <span class="n">query</span><span class="p">.</span><span class="n">SetPredicate</span><span class="p">(</span><span class="n">predicate</span><span class="p">.</span><span class="n">String</span><span class="p">());</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">Fetch</span><span class="p">()</span> <span class="o">==</span> <span class="n">B_OK</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Results of query </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">predicate</span><span class="p">.</span><span class="n">String</span><span class="p">());</span>
        <span class="n">entry_ref</span> <span class="n">ref</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">GetNextRef</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="p">)</span> <span class="o">==</span> <span class="n">B_OK</span><span class="p">)</span>
           <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">ref</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
 <span class="p">}</span>
</pre></div>
</div>
<p>代码如此简单，您可能会认为查询在第三方应用程序中会被广泛的使用。</p>
<p>由于查询汇编的方式，更加灵活的方法比较复杂。它使用一个记号堆栈——将搜索项的单个组件以特定顺序（Reverse Polish Notation，逆波兰计数法）链接在一起。每个元素都使用方法如 Pushop() 和 PushAttr() 添加到该论断结果。</p>
<p>逆波兰计数法（RPN）输入系统可以追溯到二十世纪50年代，但是它仍然应用于许多不同领域，尤其是财务和科学计算。它也被称为后缀表示法（Postfix notation），它将数学运算对象组织到一起，然后将操作符放在末尾。例如，我们通常写入的 (5+6)*3 在 RPN 中变成了 5 6 + 3 * 。如果数学操作符支持优先级，圆括号就不需要。对于计算机而言，RPN 非常简单，但是对于一般人而言确实让人头痛，因为自从我们入学伊始，代数输入就已经根深蒂固。幸运的是，查询通常都有一个简单的语法，所以以这种方式来组织查询并不是那么困难。</p>
<p>下面是使用 RPN 来组织查询的方法：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">PushAttr</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">attrName</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">PushOp</span><span class="p">(</span><span class="n">query_op</span> <span class="k">operator</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">PushUInt32</span><span class="p">(</span><span class="n">uint32</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">PushInt32</span><span class="p">(</span><span class="n">int32</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">PushUInt64</span><span class="p">(</span><span class="n">uint64</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">PushInt64</span><span class="p">(</span><span class="n">int64</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">PushFloat</span><span class="p">(</span><span class="kt">float</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">PushDouble</span><span class="p">(</span><span class="kt">double</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">PushString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">ignoreCase</span> <span class="o">=</span> <span class="nb">false</span><span class="p">);</span>
</pre></div>
</div>
<p>前两个方法用于添加属性名和比较操作符；其他的则用于添加不同类型的值。</p>
<p>如下，则是可以和 PushOp() 同时使用的操作符：</p>
<p>&lt;table border=&#8221;1&#8221;&gt;
&lt;tr&gt; &lt;td&gt;操作符&lt;/td&gt;&lt;td&gt;   操作&lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;B_EQ  &lt;/td&gt;&lt;td&gt;   ==&lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;B_NE  &lt;/td&gt;&lt;td&gt;   != &lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;B_GT  &lt;/td&gt;&lt;td&gt;   &gt; &lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;B_LT  &lt;/td&gt;&lt;td&gt;   &amp;lt; &lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;B_GE  &lt;/td&gt;&lt;td&gt;   &gt;= &lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;B_LE  &lt;/td&gt;&lt;td&gt;   &amp;lt;= &lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;B_CONTAINS  &lt;/td&gt;&lt;td&gt; 等同于正则表达式 <em>value</em> &lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;B_BEGINS_WITH &lt;/td&gt;&lt;td&gt; 等同于正则表达式 <em>value &lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;B_ENDS_WITH   &lt;/td&gt;&lt;td&gt; 等同于正则表达式 value</em> &lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;B_AND &lt;/td&gt;&lt;td&gt; &amp;&amp; &lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;B_OR  &lt;/td&gt;&lt;td&gt; || &lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;B_NOT &lt;/td&gt;&lt;td&gt; ! &lt;/td&gt; &lt;/tr&gt;
&lt;/table&gt;</p>
<p>在下面的代码中，修改先前的查询示例，使用 RPN 结果：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;Entry.h&gt;</span>
<span class="cp">#include &lt;Query.h&gt;</span>
<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;String.h&gt;</span>
<span class="cp">#include &lt;Volume.h&gt;</span>
<span class="cp">#include &lt;VolumeRoster.h&gt;</span>
<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get a BVolume object which represents the boot volume. A BQuery</span>
    <span class="c1">// object will require one.</span>
    <span class="n">BVolumeRoster</span> <span class="n">volRoster</span><span class="p">;</span>
    <span class="n">BVolume</span> <span class="n">bootVolume</span><span class="p">;</span>
    <span class="n">volRoster</span><span class="p">.</span><span class="n">GetBootVolume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bootVolume</span><span class="p">);</span>

    <span class="c1">// A quick summary for using BQuery:</span>
    <span class="c1">// 1) Make the BQuery object.</span>
    <span class="c1">// 2) Set the target volume with SetVolume().</span>
    <span class="c1">// 3) Specify the search terms with Push*().</span>
    <span class="c1">// 4) Call Fetch() to start the search</span>
    <span class="c1">// 5) Iterate over the results list using GetNextEntry(),</span>
    <span class="c1">//GetNextRef(), or GetNextDirents().</span>

    <span class="n">BString</span> <span class="n">predicate</span><span class="p">(</span><span class="s">&quot;MAIL:subject == *&quot;</span><span class="p">);</span>
    <span class="n">BQuery</span> <span class="n">query</span><span class="p">;</span>
    <span class="n">query</span><span class="p">.</span><span class="n">SetVolume</span><span class="p">(</span><span class="o">&amp;</span><span class="n">bootVolume</span><span class="p">);</span>
    <span class="n">query</span><span class="p">.</span><span class="n">PushAttr</span><span class="p">(</span><span class="s">&quot;MAIL:subject&quot;</span><span class="p">);</span>
    <span class="n">query</span><span class="p">.</span><span class="n">PushString</span><span class="p">(</span><span class="s">&quot;*&quot;</span><span class="p">);</span>
    <span class="n">query</span><span class="p">.</span><span class="n">PushOp</span><span class="p">(</span><span class="n">B_EQ</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">Fetch</span><span class="p">()</span> <span class="o">==</span> <span class="n">B_OK</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Results of query </span><span class="se">\&quot;</span><span class="s">%s</span><span class="se">\&quot;</span><span class="s">:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">predicate</span><span class="p">.</span><span class="n">String</span><span class="p">());</span>
        <span class="n">entry_ref</span> <span class="n">ref</span><span class="p">;</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">query</span><span class="p">.</span><span class="n">GetNextRef</span><span class="p">(</span><span class="o">&amp;</span><span class="n">ref</span><span class="p">)</span> <span class="o">==</span> <span class="n">B_OK</span><span class="p">)</span>
            <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">ref</span><span class="p">.</span><span class="n">name</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>需要注意的是，两种技术不能够混用。任何使用 Push 方法添加到 BQuery 的搜索项将会优先覆盖传递给 SetPredicate() 的任何内容。</p>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id12">使用实时搜索</a><a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>上述代码示例使用了静态查询——其结果被读取但未改变，可是一次查询也可以实时更新。当某个文件偶然匹配了查询或者完全消失，实时查询将发送更新消息到您的程序。</p>
<p>执行实时查询比较容易：在调用 Fetch() 之前，传递一个有效地 BHandler 或者 Blooper 到 SetTarget() 方法。尽管处理更新时需要一些策略。在接受更新消息时，可能正是您忙于使用一个 GetNext 方法读取结果之时，所以消息的处理需要和结果的读取相同步。当然，也需要注意传递给 SetTarget() 的 BMessenger 对象并没有被删除，不允许超出范围，直到您完成了查询。如果对象删除的过早将会导致更新消息不被发送。</p>
<p>查询更新消息具有标识符 B_QUERY_UPDATE。当收到消息时，之后您需要读取32位整数域opcode来获取消息包含的其他数据域。</p>
<p>Opcode B_ENTRY_CREATED：</p>
<p>&lt;table border=&#8221;1&#8221;&gt;
&lt;tr&gt; &lt;td&gt;数据域名 &lt;/td&gt;&lt;td&gt;   类型  &lt;/td&gt;&lt;td&gt;   描述&lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;Opcode     &lt;/td&gt;&lt;td&gt; Int32 &lt;/td&gt;&lt;td&gt;   消息的标识符，在这里等价于 B_ENTRY_CREATED&lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;Name     &lt;/td&gt;&lt;td&gt; String&lt;/td&gt;&lt;td&gt;   新入口的名称&lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;Directory &lt;/td&gt;&lt;td&gt;Int64 &lt;/td&gt;&lt;td&gt;   入口所处目录的 ino_t 编号&lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;Device     &lt;/td&gt;&lt;td&gt; Int32 &lt;/td&gt;&lt;td&gt;   入口所处硬件的 dev_t 编号&lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;Node     &lt;/td&gt;&lt;td&gt; Int64 &lt;/td&gt;&lt;td&gt;   入口本身的 ino_t 编号。&lt;/td&gt; &lt;/tr&gt;
&lt;/table&gt;</p>
<p>Opcode B_ENTRY_DELECTED：</p>
<p>&lt;table border=&#8221;1&#8221;&gt;
&lt;tr&gt; &lt;td&gt;数据域名 &lt;/td&gt;&lt;td&gt;   类型   &lt;/td&gt;&lt;td&gt;   描述&lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;Opcode     &lt;/td&gt;&lt;td&gt;   Int32  &lt;/td&gt;&lt;td&gt;   消息的标识符，在这里等价于 B_ENTRY_DELECTED&lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;Directory&lt;/td&gt;&lt;td&gt;   Int64  &lt;/td&gt;&lt;td&gt;   入口先前所处目录的 ino_t 编号&lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;Device     &lt;/td&gt;&lt;td&gt;   Int32  &lt;/td&gt;&lt;td&gt;   入口先前所处硬件的 dev_t 编号&lt;/td&gt; &lt;/tr&gt;
&lt;tr&gt; &lt;td&gt;Node     &lt;/td&gt;&lt;td&gt;   Int64  &lt;/td&gt;&lt;td&gt;   删除入口的 ino_t 编号&lt;/td&gt; &lt;/tr&gt;
&lt;/table&gt;</p>
<p>第一眼，您可能会觉得实时查询可能总是最好的选择。但是它们的使用也有一些缺陷：对于这些确实有用的消息，还需要计入它们额外的开销。从创建消息中获取的所有信息 —— name，node 以及其他内容等需要进行保存，因为对于 B_ENTRY_DELECTED，并没有名称域发送给它。这个关键性的消息使它不能够创建一个 entry_ref，而这恰巧是除了字符之外，最常用的存储文件或者目录位置的方式。</p>
<p>在使用实时查询时，存储由您所使用的 GetNext 方法搜集到的消息，并且以同样的方式来处理 B_ENTRY_CREATED 消息。通过这种方式，如果您接收到了 B_ENTRY_DELECTED 消息，您将能够从给定的消息中查找可能的选项。</p>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id13">总结</a><a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>查询易于使用，非常快速，并且很强大。如果您必须在系统中查找某些文件集，如在联系人管理中所有人的文件，它们提供了一种简单的方式来查找和检索文件。在您从事项目时，需要牢记于心的是——您可能会发现它们超出人们所想的新用法。</p>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id14">深入思考</a><a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>在终端中运行 lsindex 命令。它们中大多数的自我解释都非常好，但并非所有。那么您可以想到什么方法可以用于它们？</li>
<li>如果您将要编写一个音乐管理器，您将如何使用查询和属性来尽可能的加强程序，两者都进行索引么？</li>
<li>您如何在下面的个人管理程序部分利用查询：联系人，约会，任务以及电子邮件？</li>
</ul>
</div>
</div>


          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; 版权所有 2015, Haiku Chinese Group.
      最后更新于 Aug 16, 2015.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>