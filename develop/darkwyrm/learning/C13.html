<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第十三课 &mdash; Haiku 中文文档</title>
    
    <link rel="stylesheet" href="../../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="Haiku 中文文档" href="../../../index.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../../../index.html">
          <span>Haiku 中文文档</span></a></h1>
        <h2 class="heading"><span>第十三课</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id7">第十三课</a><a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id7">第十三课</a><ul>
<li><a class="reference internal" href="#id2" id="id8">继承</a></li>
<li><a class="reference internal" href="#id3" id="id9">虚函数</a></li>
<li><a class="reference internal" href="#id4" id="id10">静态函数</a></li>
<li><a class="reference internal" href="#id5" id="id11">重载：具有相同名称的函数</a></li>
<li><a class="reference internal" href="#id6" id="id12">习题</a></li>
</ul>
</li>
</ul>
</div>
<p>在上一节中，我们了解了一个编程范式，其围绕对象的设计，构建以及交互来执行一个或多个任务。我们也探究了 C++ 中对象称之为类的原因，对象的组成，以及一些其他的基本内容，但是为了成为一个高效的 Haiku 开发人员，我们需要学习更多。</p>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id8">继承</a><a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h2>
<p>Haiku 开发人员编写的很多代码都和继承相关，继承即创建一个基于其他类（基类）的类。例如，如果我们拥有一个矩形类（Rectangle），其具有高度（Height），宽度（Width），并且提供了一组用于计算面积（Area）和周长(Perimeter)的函数。创建一个长方体类（RectangularSolid）类也非常容易，仅需添加一个长度（Depth）和一个计算体积（Volume）的函数即可。</p>
<p>如果长方体类的第三个参数是它与长方形的唯一区别，那么就不必要为它们编写用于计算面积和周长的代码。如果我们仅需要为它们不同的地方编写代码，那这就太方便了。继承让这成为了可能：长方体类就称为长方形类的子类。和孩子继承父母的基因一样，子类继承了其父类的属性和方法，而我们的长方体类就继承了长方形类的所有方法和属性。</p>
<table border="1" class="docutils">
<colgroup>
<col width="8%" />
<col width="29%" />
<col width="64%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head"></th>
<th class="head">长方形</th>
<th class="head">长方体</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>属性</td>
<td>Height， Width</td>
<td>Height(继承)，Width(继承), Depth</td>
</tr>
<tr class="row-odd"><td>方法</td>
<td>Area，Perimeter</td>
<td>Area(继承)，Perimeter(继承)， Volume</td>
</tr>
</tbody>
</table>
<p>继承允许我们复用已有的代码。代码复用是 C++ 编程的基础之一。再次提醒，work smarter, not harder。</p>
<p>我们将编写一下两个类定义来分别介绍这两个例子：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Rectangle</span>
<span class="p">{</span>
<span class="nl">public:</span>
                    <span class="n">Rectangle</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
            <span class="kt">void</span>    <span class="nf">SetWidth</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">);</span>
            <span class="kt">int</span>     <span class="nf">Width</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
            <span class="kt">void</span>    <span class="nf">SetHeight</span><span class="p">(</span><span class="kt">int</span> <span class="n">height</span><span class="p">);</span>
            <span class="kt">int</span>     <span class="nf">Height</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
            <span class="kt">int</span>     <span class="nf">Area</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
            <span class="kt">int</span>     <span class="nf">Perimeter</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="nl">private:</span>
            <span class="kt">int</span>     <span class="n">fHeight</span><span class="p">;</span>
            <span class="kt">int</span>     <span class="n">fWidth</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// 这行代码说明了 RectangularSolid 是Rectangle的子类。</span>
<span class="k">class</span> <span class="nc">RectangularSolid</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Rectangle</span>
<span class="p">{</span>
<span class="nl">public:</span>
                    <span class="n">RectangularSolid</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">);</span>

            <span class="c1">// 我们不需要列出从Rectangle继承来的类，</span>
            <span class="c1">// 除了那些新出现的类。</span>
            <span class="kt">void</span>    <span class="nf">SetDepth</span><span class="p">(</span><span class="kt">int</span> <span class="n">depth</span><span class="p">);</span>
            <span class="kt">int</span>     <span class="nf">Depth</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
            <span class="kt">int</span>     <span class="nf">Volume</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="nl">private:</span>
            <span class="kt">int</span>     <span class="n">fDepth</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p>长方体类仅声明了新使用的方法和属性。编写具体的类实现将要比它们的定义需要更多的思考。这是我们第一次编写有关类的代码，所以，别走神，仔细研究一下这些代码和注释。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// Rectangle的构造函数。它将会将这些值赋给对象的属性。在为</span>
<span class="c1">// 类的方法编写代码时，类名和其后的两个冒号置于方法名之前。</span>
<span class="n">Rectangle</span><span class="o">::</span><span class="n">Rectangle</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">fWidth</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
    <span class="n">fHeight</span> <span class="o">=</span> <span class="n">heigh</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">Rectangle</span><span class="o">::</span><span class="n">SetWidth</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">fWidth</span> <span class="o">=</span> <span class="n">width</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">Rectangle</span><span class="o">::</span><span class="n">Width</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">fWidth</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">Rectangle</span><span class="o">::</span><span class="n">SetHeight</span><span class="p">(</span><span class="kt">int</span> <span class="n">height</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">fHeight</span> <span class="o">=</span> <span class="n">height</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">Rectangle</span><span class="o">::</span><span class="n">Height</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">fHeight</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">Rectangle</span><span class="o">::</span><span class="n">Area</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">fWidth</span> <span class="o">*</span> <span class="n">fHeight</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">Rectangle</span><span class="o">::</span><span class="n">Perimeter</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fWidth</span><span class="p">)</span> <span class="o">+</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">fHeight</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// 下面是 RectangularSolid 构造函数。在创建 RectangularSolid 的</span>
<span class="c1">// 同时，它第一次使用 Rectangle 的构造函数创建了一个 Rectangle 对象。</span>
<span class="c1">// 我们将跳过 height 和 width，而使用 depth 初始化 fDepth。</span>
<span class="n">RectangularSolid</span><span class="o">::</span><span class="n">RectangularSolid</span><span class="p">(</span><span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">height</span><span class="p">,</span> <span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">fDepth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Void</span>
<span class="n">RectangularSolid</span><span class="o">::</span><span class="n">SetDepth</span><span class="p">(</span><span class="kt">int</span> <span class="n">depth</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">fDepth</span> <span class="o">=</span> <span class="n">depth</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">RectangularSolid</span><span class="o">::</span><span class="n">Depth</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">fDepth</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="n">RectangularSolid</span><span class="o">::</span><span class="n">Volume</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 我们调用了 Width() 和 Height() 而不是使用 fWidth 和 fHeight，</span>
    <span class="c1">// 这是因为每个子类都没有访问该对象的私有方法和属性。</span>
    <span class="k">return</span> <span class="n">Width</span><span class="p">()</span> <span class="o">*</span> <span class="n">Height</span><span class="p">()</span> <span class="o">*</span> <span class="n">fDepth</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>这段代码和之前我们所写的代码之间的真正不同点在于，对对象的思考强制我们去关心代码的组织。编写紧凑，优雅的代码可以让它的管理和维护非常容易。</p>
<p>在这段代码中，唯一比较陌生的部分莫过于在 Volume() 中调用 Height() 和 Width()。如果子类能够访问 fWidth 和 fHeight，那岂不是更加方便，这就是 protected 的领地了。尽管您可能并不需要或者不会经常用到。</p>
<p>还有一处值得注意的地方是继承的处理，也就是 Rectangle 的 public 部分。这就是继承的类型。通常您所使用的都是公共（public）继承。这也就是说，父类方法和属性的权限不会发生改变。选择其他两种类型将会限制对基类的访问。选择保护（protected）继承将使基类的所有公共属性和方法成为 protected 而非 public，将使它们对所有的子类都可用，但是对外界则不可见。私有（private）继承将使子类所有的属性和方法成为 private，使父类对外界和任何 “grandchild” 完全无法访问。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id9">虚函数</a><a class="headerlink" href="#id3" title="Permalink to this headline">¶</a></h2>
<p>子类不仅可以添加新的方法和属性，而且也可以修改已有方法的行为。但是仅当基类允许修改时才行。而在方法声明的返回值类型前添加 virtual 关键字就提供了这种保证。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// 子类可以重新定义该方法的行为。</span>
<span class="n">Virtual</span> <span class="kt">void</span> <span class="nf">MyChangeableMethod</span><span class="p">(</span><span class="kt">int</span> <span class="n">someInt</span><span class="p">);</span>

<span class="c1">// 子类必须要重定义该方法。</span>
<span class="n">Virtual</span> <span class="kt">void</span> <span class="n">ThisMethodMustBeDefined</span><span class="p">(</span><span class="kt">float</span> <span class="n">someFloat</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</pre></div>
</div>
<p>虽然允许改变方法的行为方式，但是这并允许我们改变方法的参数类型和数量，以及其返回值类型。父类中的初始版本也并不完全消失。它可以通过作用域操作符进行指定，如下所示：</p>
<div class="highlight-cpp"><div class="highlight"><pre>void
ChildClass::DoSomething(void)
{
    Printf(“Child class did something\n);
    ParentClass::DoSomething();
}
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id10">静态函数</a><a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h2>
<p>通常，您需要调用对象的实例才能够使用其方法。有时候，这太麻烦了，难道所有的函数都必须有其“寄主”？我们可以在类的方法前面加上 static 关键字来解除该“魔咒”。静态函数和我们上述的虚函数一样，在调用时需要使用作用域操作符。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Myclass</span>
<span class="p">{</span>
<span class="nl">public:</span>
                            <span class="n">MyClass</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
                <span class="kt">int</span>         <span class="nf">DoSomething</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="k">static</span>      <span class="kt">int</span>         <span class="nf">DoSomethingStatic</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">MyClass</span> <span class="n">myClassInstance</span><span class="p">;</span>

    <span class="c1">// 调用函数的常用方法</span>
    <span class="n">MyClassInstance</span><span class="p">.</span><span class="n">DoSomething</span><span class="p">();</span>

    <span class="c1">// 下面的函数不需要实例化类。</span>
    <span class="c1">// 和常规的函数调用有略微的不同。</span>
    <span class="n">MyClass</span><span class="o">::</span><span class="n">DoSomethingStatic</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id11">重载：具有相同名称的函数</a><a class="headerlink" href="#id5" title="Permalink to this headline">¶</a></h2>
<p>使用 C 进行编程时有一个限制，几多英豪曾为此烦恼，任何两个函数都不能够同名，即使它们的参数也不相同。C++ 移除了这个枷锁，因为编译器能够根据参数的数量和类型的不同辨别出它们的区别。如下：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">MyFunction</span><span class="p">(</span><span class="kt">int</span> <span class="n">oneWay</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">MyFunction</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">anotherWay</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">MyFunction</span><span class="p">(</span><span class="kt">float</span> <span class="n">aThirdWay</span><span class="p">);</span>
</pre></div>
</div>
<p>但是，下述的例子则不行：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">SomeMethod</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">oneConstString</span><span class="p">);</span>
<span class="kt">int</span> <span class="nf">SomeMethod</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">anotherString</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">optionalString</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">);</span>
</pre></div>
</div>
<p>为何不行呢？如果您忽略 optionalString 参数，编译器将无法理解您的意图。</p>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id12">习题</a><a class="headerlink" href="#id6" title="Permalink to this headline">¶</a></h2>
<p>阅读 BeBook 中有关 BApplication，Bwindow 和 Bview 的部分。您无需理解所有的东西，但是请尽量对她们有感觉，在下一节中，我们将要为 Haiku 编织真正的花圈了。</p>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2015, Han Pengfei.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>