

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>第十课 &mdash; Haiku 中文文档</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Haiku 中文文档" href="../../../index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../../index.html" class="icon icon-home"> Haiku Chinese Documents
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../关于Haiku.html">关于 Haiku</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id1">Haiku 好处在哪儿？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id2">为何选择 Haiku ？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id3">谁支持着 Haiku ？</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../开发.html">开发</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id2">用户指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id3">开发文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../开发入门.html">开发入门</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id2">手册相关</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id3">入门任务</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id4">当您找到任务</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id5">编写代码准备</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#git">获取 GIT 提交权限</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id6">深入阅读</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku编程学习.html">Haiku编程学习</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id1">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id2">目录</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id3">参考资料和工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku编程教程.html">Haiku 编程详解</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程教程.html#id1">前言</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程教程.html#id2">内容概览</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku指南.html">Haiku 指南</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#guides-haiku"><code class="docutils literal"><span class="pre">/guides/构建Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id1"><code class="docutils literal"><span class="pre">/guides/安装Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id2"><code class="docutils literal"><span class="pre">/guides/启动Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#guides"><code class="docutils literal"><span class="pre">/guides/日常任务</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id3"><code class="docutils literal"><span class="pre">/guides/虚拟化</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id4">其他指南</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku源码规范.html">Haiku 编码规范</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id2">规范概况</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id3">缩进和空格</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id4">杂项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id5">标识符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id6">变量声明</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#haiku-api">使用 Haiku 内置的 API，类型等</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id7">注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id8">许可和版权</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id9">无用代码和调试代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id10">其他的要求</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id11">风格检查工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../开发常见问题（FAQ）.html">开发常见问题（FAQ）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id1">我是一个程序员，希望可以帮忙，那么从何开始呢？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id4">是否有简单的引导任务？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id6">是否有特定的编程风格？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id7">如何创建和提交补丁？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#trac">为什么无法在 Trac 中创建任务单？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id8">使用哪些开发工具？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id9">是否有开发者邮件列表？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#irc">是否有 IRC 聊天室？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id10">我尝试进行测试，但是 Haiku 编译失败。接下来该如何操作？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id11">我想把一些东西集成到官方源之中，可以集成那些组件？该使用何种协议呢？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#beos-haiku">我希望可以把我的 BeOS 程序/驱动移植到 Haiku，该如何进行？</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Haiku图标指南.html">Haiku 图标指南</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id1">透视效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id2">光源效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id3">渐变效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id4">色彩效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id5">阴影效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id6">轮廓线</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id7">高亮效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id8">使用覆盖</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id9">细节</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id10">中立图标</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id4">在线资源</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../开发.html#id7">开发工具</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../开发.html#id8">其他系统交叉编译</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../文档.html">文档</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id2">用户文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id3">开发者文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id4">早期文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../文档.html#bebook-be">BeBook 和 Be 信札</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../文档.html#id5">其他</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">Haiku Chinese Documents</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
    <li>第十课</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id9">第十课</a><a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id9">第十课</a><ul>
<li><a class="reference internal" href="#id2" id="id10">参数的默认值</a></li>
<li><a class="reference internal" href="#id3" id="id11">引用</a></li>
<li><a class="reference internal" href="#id4" id="id12">参数使用：传引用还是传值</a></li>
<li><a class="reference internal" href="#id5" id="id13">函数指针</a></li>
<li><a class="reference internal" href="#id6" id="id14">指针的指针</a></li>
<li><a class="reference internal" href="#id7" id="id15">命令行参数</a></li>
<li><a class="reference internal" href="#id8" id="id16">项目</a></li>
</ul>
</li>
</ul>
</div>
<p>当我们第一眼看到指针时候，我就觉得它们是非常强大的工具。今天我们就来学习一下如何在函数中使用它们，还有一些给函数传递参数的不同方法。</p>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id10">参数的默认值</a><a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>当我们调用函数的时候，会发现有时候某些参数几乎不会有什么变化，比如说我们正在写一段在屏幕上创建一个窗口的函数：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">MakeWindow</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span><span class="kt">int</span> <span class="n">top</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">right</span><span class="p">,</span><span class="kt">int</span> <span class="n">bottom</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">title</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">type</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">look</span><span class="p">);</span>
</pre></div>
</div>
<p>每次我们调用这个函数的时候，窗口的位置，大小和标题可能都各不相同，不过类型和外观很可能不太会变化，几乎每一次 type 和 look 的值都一样因为我们只是生成普通的窗口。每次都输入会浪费时间，所以我们就给这这两个参数定义个默认值。我们通过小小的修改声明文件来完成这个工作。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="nf">MakeWindow</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span><span class="kt">int</span> <span class="n">top</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">right</span><span class="p">,</span><span class="kt">int</span> <span class="n">bottom</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">title</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">type</span> <span class="o">=</span> <span class="n">REGULAR_WINDOW_TYPE</span><span class="p">,</span>
             <span class="kt">int</span> <span class="n">look</span> <span class="o">=</span> <span class="n">REGULAR_WINDOW_LOOK</span><span class="p">);</span>
</pre></div>
</div>
<p>现在我们已经为这两个参数设置了默认值，这样一来每当我们调用这个函数的时候就不必都要给这两个参数传值了。有默认值的参数都要放在参数表的最后。在这个例子中，当要创建普通窗体时就节省了很多打字工作。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">MakeWindow</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">400</span><span class="p">,</span>
        <span class="s">&quot;MyWindow&quot;</span><span class="p">,</span>
        <span class="n">REGULAR_WINDOW_TYPE</span><span class="p">,</span>
        <span class="n">REGULAR_WINDOW_LOOK</span><span class="p">);</span>
</pre></div>
</div>
<p>就可以简写成</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">MakeWindow</span><span class="p">(</span><span class="mi">100</span><span class="p">,</span><span class="mi">100</span><span class="p">,</span><span class="mi">500</span><span class="p">,</span><span class="mi">400</span><span class="p">,</span><span class="s">&quot;MyWindow&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p>在我们开始编写和 Haiku 的图型包有关的程序之前我们不会看到太多用到默认值的实例，但早点了解还是有帮助的。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id11">引用</a><a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>这里说的引用，不是某些你可以从库里找到的东西，它们其实是指针和普通变量的一种混合体，使用中它被看作是一个普通的变量，不用在前面加个星号才能读出它的值，不过它们本身有没有存储数据的空间，而是使用其他变量的存储空间。这里有个声明引用的例子：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="n">myInt</span><span class="p">;</span>
<span class="kt">int</span> <span class="o">&amp;</span><span class="n">myRef</span> <span class="o">=</span> <span class="n">myInt</span><span class="p">;</span>
</pre></div>
</div>
<p>这里在 int 和 myRef 中间的 (&amp;) 符号就是声明普通变量和声明引用的不同点，在这个例子中，myRef 是 myInt 的一个引用，myRef 是，简单说来，就是 myInt 另外的一个名字。改变它们中一个的值，另一个也会跟着改变，这对于存储了有效地址的指针也是一样的，看下列代码：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;malloc.h&gt;</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//创建一个指向堆内存空间的指针并初始化它</span>
    <span class="kt">int</span> <span class="o">*</span><span class="n">myPointer</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
    <span class="o">*</span><span class="n">myPointer</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">//创建一个myPointer指向空间的引用</span>
    <span class="kt">int</span> <span class="o">&amp;</span><span class="n">myRef</span> <span class="o">=</span> <span class="o">*</span><span class="n">myPointer</span><span class="p">;</span>

    <span class="n">myRef</span><span class="o">++</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The value at myPointer&#39;s location is %d</span><span class="se">\b</span><span class="s">&quot;</span><span class="p">,</span><span class="o">*</span><span class="n">myPointer</span><span class="p">);</span>
    <span class="n">free</span><span class="p">(</span><span class="n">myPointer</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>现在引用可能会让你想说“好吧，这玩意挺好，我们继续”，不过还有一些东西得让你知道，首先，你不能改变一个引用的指向。就是说 myRef 将永远是 myPointer 指针指向的那块内存的引用，即使 myPointer 指针自己都变了。所以如果在 myPointer 被释放后还试着使用 myRef 会引发段错误。这个不可变性其实是很有益的。一个引用必须被初始化，所以它就一直都有效，除非它引用的内存被释放或者它引用的变量出了自身的生命周期。这让引用相对指针来说更安全而同时也带来了同样的灵活性。</p>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id12">参数使用：传引用还是传值</a><a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>从函数外获取数据是有不止一种方法的。最普通的方法是传值，不过引用提供了另外一种方法。一般的，当一个参数被传入函数时，是变量的一个副本被传了进去 &#8211; 是参数的“值”被传入函数，而不是变量本身，这意味着，你可以完全不考虑在这个函数外是否会造成麻烦的随意修改这个参数。当一个参数的引用被传入函数，那在这个函数对这个参数所做的一切更改会持续到这个函数退出之后。让一个函数用引用来传递参数只需要简单在参数名前加个(&amp;)符号。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span> <span class="nf">someFunction</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">integerByReference</span><span class="p">);</span>
<span class="kt">float</span> <span class="nf">someOtherFunction</span><span class="p">(</span><span class="k">const</span> <span class="kt">double</span> <span class="o">&amp;</span><span class="n">doubleByReference</span><span class="p">);</span>
</pre></div>
</div>
<p>在这个例子里，someFunction 函数不仅返回一个字符串，而且它还可以修改 integerByReference 的值，这就相当与让我们可以通过一个函数得到两个返回值。someOtherFunction 使用了一个常引用 const reference，可能这看上去有点傻&#8211;传入一个我们不能更改的引用。但这么做其实是有目的的：它节约了一个副本。这是让一个经常被调用的函数跑的更快的一种方法，特别当这个函数有很多参数或者其中的某个参数占很大内存空间的时候。</p>
<p>现在来让我们确定一下我们的确已经了解了值传递和引用传递的区别。让我们来看一段能说明这个区别的代码：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="c1">//这个函数的x参数通过引用传递，y通过值传递</span>
<span class="kt">int</span>
<span class="nf">myFunction</span><span class="p">(</span><span class="kt">int</span> <span class="o">&amp;</span><span class="n">x</span><span class="p">,</span><span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">*</span> <span class="mi">2</span><span class="p">;</span>
    <span class="n">y</span> <span class="o">=</span> <span class="n">y</span> <span class="o">+</span> <span class="mi">5</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">x</span> <span class="o">*</span> <span class="n">y</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span> <span class="kt">void</span> <span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//为了测试来创建两个变量</span>
    <span class="kt">int</span> <span class="n">foo</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">bar</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">outValue</span> <span class="o">=</span> <span class="n">myFunction</span><span class="p">(</span><span class="n">foo</span><span class="p">,</span><span class="n">bar</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;foo is %d,bar is %d,and myFunction(foo,bar) is %d</span><span class="se">\n</span><span class="s">,</span>
               <span class="n">foo</span><span class="p">,</span><span class="n">bar</span><span class="p">,</span><span class="n">outValue</span><span class="s">&quot;);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>在这个例子中 foo 开始是 5，但由于 myFunction() 改变了它，在打印出来的时候它的值已经变成了 10，bar 的值并没有变化因为 myFunction() 函数其实只是改变了 bar 的一个副本的值。</p>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id13">函数指针</a><a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>就在你觉得指针已经没法更怪异的时候，它就更怪异了。指针不仅能够指向存储值的内存，它还能指向存储代码的地址。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">functionPointer</span><span class="p">)(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span><span class="kt">int</span> <span class="n">anotherValue</span><span class="p">);</span>
</pre></div>
</div>
<p>上面这行代码不是函数，它实际上一个叫做 functionPointer 函数指针的类型是很特殊的，返回值，参数的个数和类型都是函数指针类型的一部分。下面两个函数指针就不是一个类型的:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span> <span class="p">(</span><span class="o">*</span><span class="n">integerFunction</span><span class="p">)(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
<span class="kt">int</span> <span class="p">(</span><span class="o">*</span><span class="n">anotherIntegerFunction</span><span class="p">)(</span><span class="kt">int</span> <span class="n">value</span><span class="p">);</span>
</pre></div>
</div>
<p>用指针的方式运行一个函数简单到死：把指针当作函数名就行了。下面这个例子就调用了 integerFunction 指针所指向的函数：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="n">integerFunction</span><span class="p">(</span><span class="mi">5</span><span class="p">);</span>
</pre></div>
</div>
<p>就好像引用一样，指针函数的用处到目前来讲没那么明显。但它实际上能给程序带来难以置信的弹性。代码可以被拆上拆下的就好像汽车一样。对于类似 Perl 或者 Python 这类解释型语言，更改程序是很简单的，不过对于编译型语言比如 C++ 就没那么容易了。尽管不太多见，我们会在日后学习程序插件的时候使用到一些函数指针。现在，不用多去管它。</p>
</div>
<div class="section" id="id6">
<h2><a class="toc-backref" href="#id14">指针的指针</a><a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h2>
<p>是滴，指针还可以指向其他指针。一个指针存储的内存地址完全可以是另一个指针自身的地址。其实只要在声明指针的时候加上第 2 个星号就可以了。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">char</span> <span class="o">**</span><span class="n">somePointerToAPointer</span><span class="p">;</span>
</pre></div>
</div>
<p>不要忘记指针的声明是不会申请空间的。这个声明完成后唯一存在的是一个叫 somePointerToAPointer 的指针。我们可以把它用在很多事情上，比如从函数返回一个指针但不用返回值或者创建一个字符串列。是滴，这就是你在堆上创建一个字符串列的方法。这也是我们从命令行里得到参数的方法。</p>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id15">命令行参数</a><a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<p>就好象函数有参数，程序本身也可以接受传给它们的某些信息，让我们拿下面的终端命令做为例子：</p>
<div class="highlight-sh"><div class="highlight"><pre><span class="nv">$rm</span> -f --verbose myFile
</pre></div>
</div>
<p>这个命令 rm 有三个参数：一个文件名和 2 个开关 switches。命令行开关 command line switches 是改变程序行为的属性选择。在这个例子中，rm 作用与 myFile 之上。-f 开关告诉它要强制删除，不用确认。&#8211;verbose 开关告诉它要打印出比平时多的执行信息。</p>
<p>在 Windows 中开关以斜杠开始，而在 Linux, OS X 和 Haiku 里，它由中划线开始。还有默认的规则，一条中划线的开关只跟一个字母，而两条中划线的开关后可以跟由一条中划线分割开的词语或者短语。我们不会在课程里花太多的时间来关注命令行开关，因为我们的项目一般不会复杂到要使用它们。</p>
<p>为了能让程序占到命令行参数的便宜，我们必须改变我们写 main() 函数的方式：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>现在 main 函数有两个参数：argc 是从命令行中读取的参数的个数，argv 则是一个字符串列表，转载了命令行参数。把 argv 当成是一个数组&#8211; 如果 argc 等于 2,那 argv 就有两个元素标记是 0 和 1。 <em>argv[0]</em> 永远是当程序运行时存储这个程序名字的地方。下面这个程序将打印被传递给它的命令行参数：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span><span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Program argument %d: %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">argv</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>要注意的地方是 printf() 的最后。使用指针的指针就好像是在使用多维数组。string 只不过就是一个特殊的 char 数组。所谓我们这里就逐个的访问字符串。如果我们指向使用第一个参数的第二个字符。我们可以使用 <em>argv[0][1]</em> 。这里可能会搞混，方括号顺序是从左到右从最大组到最小组。所以是在访问列表的列表中的第 0 个元素中的第 1 个元素&#8211;也就是那个列中的第 2 个字符。</p>
</div>
<div class="section" id="id8">
<h2><a class="toc-backref" href="#id16">项目</a><a class="headerlink" href="#id8" title="永久链接至标题">¶</a></h2>
<p>学到现在，我们已经有能力利用我们所学到的一切来做出点东西了。这将会是我们第一个有价值的项目。我们要写一个 cat 命令的简略版本。文件要依照它们被输入到命令行里的顺序被依次打印到标准输出 stdout 里。</p>
<p>为了完成这个项目，我们还需要两个新函数,fread 和 fwrite:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">size_t</span> <span class="nf">fread</span> <span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span><span class="kt">siez_t</span> <span class="n">count</span><span class="p">,</span><span class="n">File</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
<span class="kt">size_t</span> <span class="nf">fwrite</span><span class="p">(</span><span class="kt">void</span> <span class="o">*</span><span class="n">buffer</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">size</span><span class="p">,</span><span class="kt">size_t</span> <span class="n">count</span><span class="p">,</span><span class="n">File</span> <span class="o">*</span><span class="n">stream</span><span class="p">);</span>
</pre></div>
</div>
<p>fread 从文件流中读取数据，这个函数将尝试读取 <em>size*count</em> 字节的数据，并把它们放在 buffer 中。这个函数非常好使，因为你可以为 buffer 申请任意类型的数组。使用 sizeof() 函数确定类型的大小给 size，然后设定数组里元素的个数给 count，fread 返回真正被读取的元素的个数。如果这和被要求的个数不一样，那就要么有错误发生，要么就是文件读到头了。</p>
<p>fwrite 和 fread 工作模式很像，但是是逆向的，在 buff 中的数据会被写到 stream 里，实际被写入流的元素的个数被作为返回值返回。</p>
<p>总体说来，这个项目包含了我们刚学到的如果使用命令行参数，结合第8课里的文件操作加上 fread 和 fwrite。使用 for 循环来为每个命令行参数执行下面这一连串操作：</p>
<ol class="arabic simple">
<li>尝试将参数当文件打开用于读取</li>
<li>如果打开错误，跳到下一个循环</li>
<li>如果打开成功，尝试读取文件的一块，把读取的字节数储存在一个变量中</li>
<li>使用 while 循环读取文件内的数据，当读取的字节数大于 0 的时候不停的循环</li>
<li>把读取的字节数打印在标准输出里</li>
<li>尝试从文件流中读取更多的数据，并保存实际读取的字节数</li>
<li>关闭文件流</li>
</ol>
<p>提示，警告和建议：</p>
<ul class="simple">
<li>使用 ferror 来打印文件错误是一个很好的尝试</li>
<li>用来储存文件数据的内存块可以来自堆也可以来自栈</li>
</ul>
<p>因为我们还没有真正写过什么代码，所以我来帮你入一下门。你要做的就是把每行评论都替换成真正的代码就行了。每次写一点编译一点是个很好的做法。一步步的写代码，测试代码有助于定位 Bug 和让 Bug 最小化</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;malloc.h&gt;</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">argc</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="c1">// 为了从argv[i]中读取数据打开一个文件流</span>
    <span class="c1">// 如果文件流为NULL或者有错误，则进入下一个循环</span>
    <span class="c1">// 创建一个数据缓冲 -- 一个存放我们数据的数组，大小不是很重要</span>
    <span class="c1">// 但它至少应该有几百字节大,但不要大过4000字节</span>
    <span class="c1">// 你可以把它创建在栈上</span>
    <span class="c1">// 或者使用malloc，你爱怎么做都可以</span>
    <span class="c1">// 创建一个变量来存储真正读出的字节的个数</span>
    <span class="c1">// 从文件流里读取数据并存储读出的字节个数</span>
    <span class="c1">// 读取我们刚建立的变量的值</span>
    <span class="c1">// 开始while循环，如果读出的字节的个数大于0,</span>
    <span class="c1">// 并且文件流没有出现ferror错误，则一直循环</span>
    <span class="p">{</span>
        <span class="c1">// 把读取的字节个数输出到标准输出stdout里</span>
        <span class="c1">// 读取更多的数据并更新读取的字节个数</span>
        <span class="c1">// 到我们上面创建的那个变量里</span>
    <span class="p">}</span>
    <span class="c1">// 如果你使用了malloc，则释放缓存</span>
    <span class="c1">// 如果你使用的是栈空间，就不要管了</span>
    <span class="c1">// 关闭文件流</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>


          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; 版权所有 2015, Haiku Chinese Group.
      最后更新于 Aug 18, 2016.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>