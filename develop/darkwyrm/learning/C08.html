

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>第八课 &mdash; Haiku 中文文档</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Haiku 中文文档" href="../../../index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../../index.html" class="icon icon-home"> Haiku Chinese Documents
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../关于Haiku.html">关于 Haiku</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id1">Haiku 好处在哪儿？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id2">为何选择 Haiku ？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id3">谁支持着 Haiku ？</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../开发.html">开发</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id2">用户指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id3">开发文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../开发入门.html">开发入门</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id2">手册相关</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id3">入门任务</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id4">当您找到任务</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id5">编写代码准备</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#git">获取 GIT 提交权限</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id7">深入阅读</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku编程学习.html">Haiku编程学习</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id1">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id2">目录</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id3">参考资料和工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku编程教程.html">Haiku 编程详解</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程教程.html#id1">前言</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程教程.html#id2">内容概览</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku指南.html">Haiku 指南</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#guides-haiku"><code class="docutils literal"><span class="pre">/guides/构建Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id1"><code class="docutils literal"><span class="pre">/guides/安装Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id2"><code class="docutils literal"><span class="pre">/guides/启动Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#guides"><code class="docutils literal"><span class="pre">/guides/日常任务</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id3"><code class="docutils literal"><span class="pre">/guides/虚拟化</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id4">其他指南</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku源码规范.html">Haiku 编码规范</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id2">规范概况</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id3">缩进和空格</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id4">杂项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id5">标识符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id6">变量声明</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#haiku-api">使用 Haiku 内置的 API，类型等</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id7">注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id8">许可和版权</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id9">无用代码和调试代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id10">其他的要求</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id11">风格检查工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../开发常见问题（FAQ）.html">开发常见问题（FAQ）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id1">我是一个程序员，希望可以帮忙，那么从何开始呢？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id4">是否有简单的引导任务？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id6">是否有特定的编程风格？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id7">如何创建和提交补丁？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#trac">为什么无法在 Trac 中创建任务单？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id8">使用哪些开发工具？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id9">是否有开发者邮件列表？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#irc">是否有 IRC 聊天室？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id10">我尝试进行测试，但是 Haiku 编译失败。接下来该如何操作？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id11">我想把一些东西集成到官方源之中，可以集成那些组件？该使用何种协议呢？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#beos-haiku">我希望可以把我的 BeOS 程序/驱动移植到 Haiku，该如何进行？</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Haiku图标指南.html">Haiku 图标指南</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id1">透视效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id2">光源效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id3">渐变效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id4">色彩效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id5">阴影效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id6">轮廓线</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id7">高亮效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id8">使用覆盖</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id9">细节</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id10">中立图标</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id4">在线资源</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../开发.html#id7">开发工具</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../开发.html#id8">其他系统交叉编译</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../文档.html">文档</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id2">用户文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id3">开发者文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id4">早期文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../文档.html#bebook-be">BeBook 和 Be 信札</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../文档.html#id5">其他</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">Haiku Chinese Documents</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
    <li>第八课</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id8">第八课</a><a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id8">第八课</a><ul>
<li><a class="reference internal" href="#id2" id="id9">作用域</a></li>
<li><a class="reference internal" href="#id3" id="id10">常量</a></li>
<li><a class="reference internal" href="#id4" id="id11">外部数据使用：文件操作</a></li>
<li><a class="reference internal" href="#id5" id="id12">错误查找</a><ul>
<li><a class="reference internal" href="#id6" id="id13">错误 #1</a></li>
</ul>
</li>
<li><a class="reference internal" href="#id7" id="id14">第七课错误查找答案</a></li>
</ul>
</li>
</ul>
</div>
<p>因为目前我们重点介绍了 C++ 语言的结构，并没有给予我们程序信息的输入输出足够的重视。那么这次我们将会做出改变，但是首先，我们需要快速的查看一下那些被我们所忽视的细微之处。</p>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id9">作用域</a><a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>无须对牙刷感到奇怪，尽管考虑到某些开发人员的卫生习惯，不是一个坏主意。幸运的是，在网络上，没有人会知道你是个小猫咪。</p>
<p>在这里， <strong>作用域</strong> 作用于变量。一个变量的作用域是它的存在范围。当一个变量声明之后，它具有一个确定的开始，并且在源代码中，它无法在声明之前使用。并且当运行到达它所声明的区域结束的地方时，它将会完全消失。</p>
<p>作用域有三种类型：局部的，全局的，以及静态的。局部变量具有最短的生命周期：它们在代码块中进行声明，如函数，for 循环，或者 case 语句中，并且当程序离开代码块时，它将会消失。</p>
<p>全局变量和静态变量在函数之外声明。它们总是可以被访问，但是它们初始化的顺序是不确定的，因此需要注意哪些依赖于其他全局变量值的全局变量。全局变量在任何地方都可以访问。静态变量和全局变量具有同样的声明周期，但是它们仅可以在其所定义的文件的代码中所使用。换句话说，其他文件中的代码无法访问它们。所有这些可能比较复杂，但是在代码中还是比较容易理解，我们且看下面的示例：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="c1">// 下面是一个全局变量，可以在任何地方进行访问</span>
<span class="kt">int</span> <span class="n">gAppReturnValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">AreaOfSquare</span><span class="p">(</span><span class="kt">int</span> <span class="n">size</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">size</span> <span class="o">*</span> <span class="n">size</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">returnValue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

    <span class="c1">// 由于计算 0 英寸的平方比较简单，</span>
    <span class="c1">// 我们在本循环中从 1 开始。</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;=</span> <span class="mi">12</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// i 仅在本循环中可以访问。</span>

        <span class="c1">// 如果我们需要利用 returnValue，我们可以在这里使用。</span>
        <span class="kt">int</span> <span class="n">area</span> <span class="o">=</span> <span class="n">AreaOfSquare</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The area of a square %d inches on a side is &quot;</span>
             <span class="s">&quot;%d square inches</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">i</span><span class="p">,</span><span class="n">area</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">// 如果我们尝试在循环之外访问 area 变量，</span>
    <span class="c1">// 编译器将会显示错误，其类似于</span>
    <span class="c1">// &quot;foo.cpp:30; error: &#39;area&#39; was not declared in this scop&quot;</span>

    <span class="k">return</span> <span class="n">gAppReturnValue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>看了上面的例子，您应该注意到了您所定义的变量名。代码中这个长长的全局变量具有一个小写的前缀 &#8216;g&#8217;。它用于说明其为一个全局变量。静态变量则使用前缀 &#8216;s&#8217; 而不是 &#8216;g&#8217;。尝试养成使用前缀的习惯可以避免许多头痛的事。</p>
<p>如果您和我相似，您可能会想知道我所说的让人头痛的事究竟为何事。请看下面的示例，然后猜测打印的结果是什么。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="c1">//这是一个全局变量，可以在文件中的任何地方进行访问。</span>
<span class="k">static</span> <span class="kt">int</span> <span class="n">returnValue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">returnValue</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot; The return value of this program is %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span><span class="n">returnValue</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">returnValue</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>如果您太懒而不想尝试该示例，我可以告诉你，其结果为 2。通过命令我们的静态变量为 sReturnValue ，我们可以非常简单的避免这种情况。当存在作用域冲突时，局部变量总是取得优先权。当然，也能够使用这种方式隐藏参数或预声明局部变量，例如 if 语句中的变量会对函数开头声明的变量隐藏。需要注意的是，不要使用函数中声明的变量隐藏其参数。</p>
<p>全局和静态变量非常像厨艺中的佐料：少量使用，它们确实可以使程序很简单；但是使用太多，它们将会起到相反的作用。当无法确定时，不要使用全局变量传递数据 - 而是应该使用函数参数。这样做可以很容易的实现代码的复用。总之，工作之中，多用智慧，减少难度。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id10">常量</a><a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>在 C 和 C++ 中并不是所有的内容都需要修改。有些时候，我们需要保证某些数据不被修改。在其他时候，我们希望使用变量来存储某些随意的数值 - 我们不关心这些值的变化，但是我们需要存储它的目的。当我们编写使用窗口和按钮的 Haiku 程序时，我们将会使用很多这些内容以指定所使用的控件的行为，例如它们的尺寸控制。</p>
<p>第一类常量是预处理程序定义。如果您不大记得第二课中所学，预处理器是编译源代码为可执行程序过程中所使用的第一个工具。预处理器移除注释，包括头文件，以及其他基础的插入和替代文本。它们如下所示：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#define SOMEDEF &quot; I like cheese!&quot;</span>
<span class="cp">#define STRACE(x) printf x</span>
</pre></div>
</div>
<p>格式非常简单：<em>#define</em> 。它们是简单的文本替换，非常类似于字处理程序的替换，把所有的 SOMEDEF 替换为 &#8220;I like cheese!&#8221;。编译器所关心的就是，您是否输入了 SOMEDEF。您甚至可以使它们看起来像一个函数，如 STRACE。在本课结束，我们会对它有更加详细的讨论，因此敬请期待。</p>
<p><em>#define</em> 需要谨慎的处理，比数组有过之而不及。在实际应用中，将其写为大写形式比较好，这样可以区别于函数。它们也是无需注意类型的，并且还有一个警告：无论它们如何祈求，无论它们如何哭泣, <strong>不要，请不要在预处理定义之后添加分号</strong> 。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// 请不要这样做</span>
<span class="cp">#define THISISBAD 1;</span>
</pre></div>
</div>
<p>这样做将会导致代码出错，但是可能并不会带来真正的问题。这种类型的错误可能会让您觉得自己太过仓促，尽管您并非如此。</p>
<p>常变量是推崇的存储随意值的方法，因为它们具有定义类型。可以在变量声明之前添加 const 关键字来实现。因为它们不允许修改，当其声明时，您总能够看到常量的初始化。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="k">const</span> <span class="kt">int</span> <span class="n">someConstIntValue</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
</pre></div>
</div>
<p>指针也可以成为常量，但是如果您不够谨慎，它很快就会让您产生疑惑。const 关键字可以作用于指针的地址，指针本身，或两者皆可。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="c1">// 这只是一个整型常量，我们将会将其用于下面的一些指针。</span>
<span class="k">const</span> <span class="kt">int</span> <span class="n">someVariable</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>

<span class="c1">// 以下两个都是到整型的指针，我们可以修改指针的地址，</span>
<span class="c1">// 但是无法修改它的值，因此它们无需进行初始化。</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span><span class="n">ptrConstInt</span><span class="p">;</span>
<span class="kt">int</span> <span class="k">const</span> <span class="o">*</span><span class="n">anotherPtrConstInt</span><span class="p">;</span>

<span class="c1">// 这是一个常量指针。其本身的值可以修改，但是我们无法修改</span>
<span class="c1">// 指针所指向的地址。除非我们对它进行初始化，否则毫无用处。</span>
<span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="n">constPtrInt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">foo</span><span class="p">;</span>

<span class="c1">// 以下这些是指向常量值的常量指针。我们无法关于它的任何内容，</span>
<span class="c1">// 也就是说，无论用于何种用途，它都必须进行初始化。</span>
<span class="k">const</span> <span class="kt">int</span> <span class="o">*</span> <span class="k">const</span> <span class="n">ptrReallyConstInt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">someVariable</span><span class="p">;</span>
<span class="kt">int</span> <span class="k">const</span> <span class="o">*</span> <span class="k">const</span> <span class="n">anotherPtrReallyConstInt</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">someVariable</span><span class="p">;</span>
</pre></div>
</div>
<p>实在是太混乱了！有一个简单的规则可以解决所有的疑惑。<strong>const关键字作用于其左端的元素，如果其左端为空，那么其作用域其右端的元素</strong> 。在上述的前两个例子中，每次遇到 const int 或 int const，都意味着，指针本身可以修改，但是指针指向的地址中的值无法修改。每次您遇到 * const ，也就意味着指针的地址被锁定，但是指针地址中的值可以修改。最后两个例子综合了两种技术，使所有内容都为常量，包括地址和数值。如果您对此仍存疑惑，请无需担心太多 - 不仅仅您存在这种情况。这原本就是一个有难度的话题。</p>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id11">外部数据使用：文件操作</a><a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>我们所知道的唯一为我们的程序获取信息的方法是 gets()，并且唯一输出信息的方法是 printf()。printf() 还算可以，但是 gets() 却非常危险，并且无论何时编译器遇到它，都会给我们以警告。其缘由就是，没有办法来强制限定传递给它的字符串中字符的数量。由于输入的字符数量多于给以的数组的容量时，程序很容易就会崩溃。因此我们需要一个更好的解决方案。</p>
<p>程序中信息的输入输出通常是通过使用数据流来实现的。信息流进或流出您的程序。用户的直接输入是一个数据流，并且屏幕也是 - 用于输出的数据流。控制台程序利用流来获取和打印信息，并且它们可以组织到一起：当我们运行称为 bash 的 Terminal 时所使用的程序具有非常难以置信的能力，它能够接受某个程序的输出，并且可以将供其他程序使用，或者将其导入文件，这些直接的通道称之为**管道**。</p>
<p>对于每个程序，都有三种主要的流可用：stdin，标准输入，stdout，标准输出，以及 stderr，错误输出。如果不做修改，那么程序将会通过 stdin 从用户获取输入，跟我们所使用的 gets() 相似，并且发送任何内容到 stdout 或者打印 stderr 到屏幕。</p>
<p>数据可以通过数据流的读入而进入我们的程序，而且可以通过写入数据流从而从我们的程序中输出。有些流是只读的，一些是只写的，还有一些同时允许读和写。stdin 是只读的，因此我们可以使用它用于获取数据，stdout 和 stderr 是只写的，因此我们仅打印它们，如果我们创建一个流来操作文件，我们可以选择其中之一或者同时使用两者。</p>
<p>每个流都有一个标识符，称为**句柄**。在编程时，句柄是随主观而定的 - 但是通常是独立的 - 数值，其用于区别不同种类的对象。对流的操作很简单，就是获取流的句柄，然后调用合适的函数。我们来看一下我们在日常的 C 编程中所使用的几个函数的声明。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="kt">int</span> <span class="nf">fprintf</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">streamHandle</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
</pre></div>
</div>
<p>较早的标准。给定一个定义了打印内容格式的字符串，以及其后恰当数量的参数，然后打印字符串到 stdout 。fprintf() 需要在格式字符串之前指定一个流处理操作 - 使它能够直接“打印”文件 - 否则其和 printf() 一样。当成功时，这两个函数返回打印字符的数量。负数值用于表示运行失败。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">ferror</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">streamHandle</span><span class="p">);</span>
</pre></div>
</div>
<p>如果由 streamHandle 标识的流一切正常，返回的结果为 0，如果发生错误，那么返回的结果将为其他未指定的值。请确保 streamHandle 不为 NULL - 否则您的程序将会发生段错误。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">feof</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">streamHandle</span><span class="p">);</span>
</pre></div>
</div>
<p>如果由 streamHandle 标识的流一切正常，返回的结果为 0；如果流到达了文件的结尾，那么返返回的结果将为其他未指定的值。请确保 streamHandle 不为 NULL - 否则您的程序将会发生段错误。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">char</span> <span class="o">*</span> <span class="nf">fgets</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">arraySize</span><span class="p">,</span> <span class="kt">FILE</span> <span class="o">*</span><span class="n">streamHandle</span><span class="p">);</span>
</pre></div>
</div>
<p>fgets() 是 gets() 的安全版本。它从流句柄里读取文本直到遇到了换行符 (&#8216;n&#8217;)或者它读取到的字符数量等于 arraySize，如果程序员产生了错误，将可能会产生段错误。和 gets() 相同，当成功时，fgets()返回 array 指针。如果出现错误，它将会返回 NULL 指针。如果 fgets() 到达了文件的结尾 - 仅从文件而不是 stdin 读取 - 数组中的内容将不会改变，但是将会返回 NULL 指针。无论何时 fgets() 返回了 NULL 指针，请使用 feof() 或者 ferror() 检查是否发生了数据溢出或者发生了某些错误。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">FILE</span> <span class="o">*</span> <span class="nf">fopen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filePath</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">mode</span><span class="p">);</span>
</pre></div>
</div>
<p>fopen() 以流方式打开文件。如果成功，它将会返回其他函数使用的流句柄，并且最终必须使用 fclose() 进行关闭。模式字符串如下表：</p>
<table border="1" class="docutils">
<colgroup>
<col width="11%" />
<col width="89%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">模式字符串</th>
<th class="head">功能</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>&#8220;r&#8221;</td>
<td>打开读取文件。该文件必须存在。</td>
</tr>
<tr class="row-odd"><td>&#8220;w&#8221;</td>
<td>打开写入文件。如果文件存在，其内容将被擦除，并且它被视为新的空文件。</td>
</tr>
<tr class="row-even"><td>&#8220;a&#8221;</td>
<td>打开写入文件。任何写入的数据将添加到文件末尾。如果文件不存在，它将被创建。</td>
</tr>
<tr class="row-odd"><td>&#8220;r+&#8221;</td>
<td>打开更新文件，同时支持读取和写入。文件必须存在。</td>
</tr>
<tr class="row-even"><td>&#8220;w+&#8221;</td>
<td>打开更新文件，同时支持读取和写入，如果文件存在，其内容将被擦除，它被视为新的空文件。</td>
</tr>
<tr class="row-odd"><td>&#8220;a+&#8221;</td>
<td>打开写入和追加文件。可以从文件任何地方进行读取，但是所有写入的内容将添加到文件末尾。</td>
</tr>
</tbody>
</table>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">fclose</span><span class="p">(</span><span class="kt">FILE</span> <span class="o">*</span><span class="n">streamHandle</span><span class="p">);</span>
</pre></div>
</div>
<p>关闭打开的流句柄。</p>
<p>哇哦，有许多函数哟！比较骇人的部分是，这只是可用函数中很小的一部分。一个程序员必须时刻在学习。一旦他熟悉了一门语言，他总是在学习那些不太熟悉的可用函数，以及新的使用已知函数的方式。最好的学习如何使用不熟悉的函数的方式是使用它们。</p>
<p>让我们查看以下这个打印测试文件到 stdout 并创建需要文件的程序。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>

<span class="kt">int</span>
<span class="nf">FileExists</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 该函数通过尝试打开文件来测试文件的存在性。</span>
    <span class="c1">// 当然还有其它方式可以处理，但是这种方法对</span>
    <span class="c1">// 我们来说暂时已经足够了。</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="c1">// 尝试打开读取文件</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">path</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>

    <span class="c1">// 如果文件存在，返回值将会为 1 ，否则为 0。</span>
    <span class="c1">// 如果打开文件出错，ferror() 将会返回非零结果，</span>
    <span class="c1">// 如果文件打开正常，则返回 0 。</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span> <span class="o">||</span> <span class="n">ferror</span><span class="p">(</span><span class="n">file</span><span class="p">)</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">returnValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span>
    <span class="p">{</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
    <span class="n">returnValue</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">returnValue</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">MakeTestFile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 在处理字符串时，总是检查 NULL 指针。</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="c1">// 打开文件，如果其存在，则擦除其内容。</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="s">&quot;w&quot;</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">file</span> <span class="o">||</span> <span class="n">ferror</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="c1">// 如果我们不创建文件，我们将会产生不同的错误代码。</span>
    <span class="c1">// 这样可以让我们知道是否是因为传递 NULL 指针或者存在</span>
    <span class="c1">// 文件相关的错误而出现问题。</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t create the file %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// 用于 stdout，stdin，和 stderr 的流句柄已经进行了定义，</span>
    <span class="c1">// 因此我们可以直接进行使用，如在上述的 if() 条件，以及</span>
    <span class="c1">// 下述的传递数据到我们的文件。</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">file</span><span class="p">,</span> <span class="s">&quot;This is a file.</span><span class="se">\n</span><span class="s">This is only a file.</span><span class="se">\n</span><span class="s">&quot;</span>
                        <span class="s">&quot;Had this been a real emergency, do you think I&#39;d &quot;</span>
                        <span class="s">&quot;be around to tell you?</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span>
<span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">returnValue</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="c1">// 让我们使用 /boot/home 中的 MyTestFile.txt 测试文件。</span>
    <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">filePath</span> <span class="o">=</span> <span class="s">&quot;/boot/home/MyTestFile.txt&quot;</span><span class="p">;</span>

    <span class="c1">// 如果不存在，则创建测试文件。如果创建出现问题，则释放我们的程序。</span>
    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">FileExist</span><span class="p">(</span><span class="n">filePath</span><span class="p">)</span>
    <span class="p">{</span>
    <span class="n">returnValue</span> <span class="o">=</span> <span class="n">MakeTestFile</span><span class="p">(</span><span class="n">filePath</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">returnValue</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">returnValue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Printing file %s:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filePath</span><span class="p">);</span>

    <span class="c1">// 我们到现在这一步，可以安全的打印文件了。</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">file</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">filePath</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>

    <span class="k">if</span><span class="p">(</span><span class="o">!</span><span class="n">file</span> <span class="o">||</span> <span class="n">ferror</span><span class="p">(</span><span class="n">file</span><span class="p">))</span>
    <span class="p">{</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stderr</span><span class="p">,</span> <span class="s">&quot;Couldn&#39;t print the file %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">filePath</span><span class="p">);</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">char</span> <span class="n">inString</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

    <span class="c1">// 当 fgets 到达文件的末尾时，它将会返回一个 NULL 指针。因此这个小循环</span>
    <span class="c1">// 将会打印整个文件，在末尾时退出。</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">fgets</span><span class="p">(</span><span class="n">inString</span><span class="p">,</span> <span class="mi">1024</span><span class="p">,</span> <span class="n">file</span><span class="p">))</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">stdout</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">inString</span><span class="p">);</span>

    <span class="n">fclose</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>哎哟！这就是我们最长的代码示例了，也是最接近“真实”程序的代码。一些习惯，如 if (!file) ，对于 C 和 C++ 编程非常普遍，所以请不要见怪。阅读了该示例中的代码，请确保了解每行代码的用意。</p>
<p>在代码风格方面也有一些小的改变。对代码风格的关注是 Haiku 环境的一个怪癖。特别的是，Haiku 开发者尤其挑剔代码，始终遵循 OpenTracker 中的代码风格。风格需要部分的关注，但是好的代码风格也有助于代码调试和避免错误。不好的代码风格可以使之非常困难。在接下来的章节中，我们将要使用的风格可能会有别于官方的 Haiku 代码规范，但是它和它们非常的接近。</p>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id12">错误查找</a><a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<div class="section" id="id6">
<h3><a class="toc-backref" href="#id13">错误 #1</a><a class="headerlink" href="#id6" title="永久链接至标题">¶</a></h3>
<p>代码:</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="kt">char</span> <span class="o">*</span><span class="nf">ReverseString</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// 该函数对字符串重新倒装排序。</span>
    <span class="c1">// 如，abcdef -&gt; fedcba</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">string</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>

    <span class="kt">int</span> <span class="n">length</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">string</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="n">length</span> <span class="o">/</span> <span class="mi">2</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="mi">1</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">char</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">length</span> <span class="o">-</span> <span class="n">i</span><span class="p">];</span>
        <span class="n">string</span><span class="p">[</span><span class="n">length</span> <span class="o">-</span> <span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="n">string</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">string</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">char</span> <span class="n">inString</span><span class="p">[</span><span class="mi">1024</span><span class="p">];</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Type a string to reverse:&quot;</span><span class="p">);</span>
    <span class="n">gets</span><span class="p">(</span><span class="n">inString</span><span class="p">);</span>

    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;The reversed string is %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ReverseString</span><span class="p">(</span><span class="n">inString</span><span class="p">);</span>

    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>错误:</p>
<div class="highlight-sh"><div class="highlight"><pre>foo.cpp: In <span class="k">function</span> <span class="s1">&#39;char* ReverseString(const char*)&#39;</span><span class="p">;</span>
foo.cpp:18: error: assignment of <span class="nb">read</span>-only location <span class="s1">&#39;*(string + ((unsigned int)</span>
<span class="s1">((length + 0x00000000000000001) - i)))&#39;</span>
foo.cpp:19: error: assignment of <span class="nb">read</span>-only location <span class="s1">&#39;*(string + ((unsigned int)</span>
<span class="s1">i))&#39;</span>
foo.cpp:22: error: invalid conversion from <span class="s1">&#39;const char*&#39;</span> to <span class="s1">&#39;char*&#39;</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="id7">
<h2><a class="toc-backref" href="#id14">第七课错误查找答案</a><a class="headerlink" href="#id7" title="永久链接至标题">¶</a></h2>
<ol class="arabic simple">
<li>combinedString 指针没有指向有效的内存地址。它需要通过 malloc() 给定堆内存 - 之后需要释放 - 或者在堆上声明为数组。</li>
<li>main() 函数中的 binaryString 数组大小不够。它至少能够为一个字节中的每个位存放一个字符，还有一个空余用于存放 NULL 终止符，因此 binaryString 数组至少能够存放 9 个字符而不是 6 个。</li>
</ol>
</div>
</div>


          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; 版权所有 2015, Haiku Chinese Group.
      最后更新于 Aug 18, 2016.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>