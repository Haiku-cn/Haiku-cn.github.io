

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>第二十一课 &mdash; Haiku 中文文档</title>
  

  
  

  

  
  
    

  

  
  
    <link rel="stylesheet" href="../../../_static/css/theme.css" type="text/css" />
  

  

  
    <link rel="top" title="Haiku 中文文档" href="../../../index.html"/> 

  
  <script src="_static/js/modernizr.min.js"></script>

</head>

<body class="wy-body-for-nav" role="document">

  <div class="wy-grid-for-nav">

    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-nav-search">
        

        
          <a href="../../../index.html" class="icon icon-home"> Haiku Chinese Documents
        

        
        </a>

        
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

        
      </div>

      <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
        
          
          
              <ul>
<li class="toctree-l1"><a class="reference internal" href="../../../关于Haiku.html">关于 Haiku</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id1">Haiku 好处在哪儿？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id2">为何选择 Haiku ？</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../关于Haiku.html#id3">谁支持着 Haiku ？</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../开发.html">开发</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id2">用户指南</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id3">开发文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../开发入门.html">开发入门</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id2">手册相关</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id3">入门任务</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id4">当您找到任务</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id5">编写代码准备</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#git">获取 GIT 提交权限</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发入门.html#id7">深入阅读</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku编程学习.html">Haiku编程学习</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id1">简介</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id2">目录</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程学习.html#id3">参考资料和工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku编程教程.html">Haiku 编程详解</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程教程.html#id1">前言</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku编程教程.html#id2">内容概览</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku指南.html">Haiku 指南</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#guides-haiku"><code class="docutils literal"><span class="pre">/guides/构建Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id1"><code class="docutils literal"><span class="pre">/guides/安装Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id2"><code class="docutils literal"><span class="pre">/guides/启动Haiku</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#guides"><code class="docutils literal"><span class="pre">/guides/日常任务</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id3"><code class="docutils literal"><span class="pre">/guides/虚拟化</span></code></a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku指南.html#id4">其他指南</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../Haiku源码规范.html">Haiku 编码规范</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id2">规范概况</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id3">缩进和空格</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id4">杂项</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id5">标识符</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id6">变量声明</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#haiku-api">使用 Haiku 内置的 API，类型等</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id7">注释</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id8">许可和版权</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id9">无用代码和调试代码</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id10">其他的要求</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../Haiku源码规范.html#id11">风格检查工具</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../../开发常见问题（FAQ）.html">开发常见问题（FAQ）</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id1">我是一个程序员，希望可以帮忙，那么从何开始呢？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id4">是否有简单的引导任务？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id6">是否有特定的编程风格？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id7">如何创建和提交补丁？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#trac">为什么无法在 Trac 中创建任务单？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id8">使用哪些开发工具？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id9">是否有开发者邮件列表？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#irc">是否有 IRC 聊天室？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id10">我尝试进行测试，但是 Haiku 编译失败。接下来该如何操作？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#id11">我想把一些东西集成到官方源之中，可以集成那些组件？该使用何种协议呢？</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../../开发常见问题（FAQ）.html#beos-haiku">我希望可以把我的 BeOS 程序/驱动移植到 Haiku，该如何进行？</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../../Haiku图标指南.html">Haiku 图标指南</a><ul>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id1">透视效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id2">光源效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id3">渐变效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id4">色彩效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id5">阴影效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id6">轮廓线</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id7">高亮效果</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id8">使用覆盖</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id9">细节</a></li>
<li class="toctree-l4"><a class="reference internal" href="../../Haiku图标指南.html#id10">中立图标</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../../开发.html#id4">在线资源</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../开发.html#id7">开发工具</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../开发.html#id8">其他系统交叉编译</a></li>
</ul>
</li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="../../../文档.html">文档</a><ul>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id2">用户文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id3">开发者文档</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../../文档.html#id4">早期文档</a><ul>
<li class="toctree-l3"><a class="reference internal" href="../../../文档.html#bebook-be">BeBook 和 Be 信札</a></li>
<li class="toctree-l3"><a class="reference internal" href="../../../文档.html#id5">其他</a></li>
</ul>
</li>
</ul>
</li>
</ul>

          
        
      </div>
      &nbsp;
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" role="navigation" aria-label="top navigation">
        <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
        <a href="../../../index.html">Haiku Chinese Documents</a>
      </nav>


      
      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="breadcrumbs navigation">
  <ul class="wy-breadcrumbs">
    <li><a href="../../../index.html">Docs</a> &raquo;</li>
      
    <li>第二十一课</li>
      <li class="wy-breadcrumbs-aside">
        
          
        
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document">
            
  <div class="section" id="id1">
<h1><a class="toc-backref" href="#id6">第二十一课</a><a class="headerlink" href="#id1" title="永久链接至标题">¶</a></h1>
<div class="contents topic" id="contents">
<p class="topic-title first">Contents</p>
<ul class="simple">
<li><a class="reference internal" href="#id1" id="id6">第二十一课</a><ul>
<li><a class="reference internal" href="#id2" id="id7">项目概览</a></li>
<li><a class="reference internal" href="#bfile" id="id8">BFile：使文件完全按照要求“端坐”和“犬吠”</a></li>
<li><a class="reference internal" href="#id3" id="id9">使用 BFile 读和写文件</a></li>
<li><a class="reference internal" href="#haikufortune" id="id10">开始我们的项目：HaikuFortune</a></li>
<li><a class="reference internal" href="#id4" id="id11">编写和测试代码</a></li>
<li><a class="reference internal" href="#id5" id="id12">深入学习</a></li>
</ul>
</li>
</ul>
</div>
<p>我们所有的项目都不是很大，通常都不会花费很多时间。但是根据项目复杂性的大小，真实的编程项目可能会需要几个月或者更多的时间。在这一节里，我们将开始一个新的项目，相比于其他的许多 Haiku 程序，它比较小，但是我们需要好几个章节来完成这一项目。</p>
<div class="section" id="id2">
<h2><a class="toc-backref" href="#id7">项目概览</a><a class="headerlink" href="#id2" title="永久链接至标题">¶</a></h2>
<p>我们的项目相比较小。Unix 系统已经存在好长时间了，其中有一个命令行程序 fortune，它用于智能显示一些类型。通常在用户登录系统时，它就会运行。那么我们将会来编写一个 fortune 图形化程序而不是终端中的程序。由于我们不限于一个 fortune 文件，它将在原始的程序上有所给进。而且它将会在 fortune 中随机选择一个文件，然后在该文件中随机的选择一个入口。我们将会让用户能够按照自己的意愿来选择 fortune 程序。</p>
<p>我们将会把代码分为两个主要的部分：GUI 和 fortune 的具体实现代码。fortune 的代码是一个类，它主要用于从 fortune 目录中选择 fortune 文件，从文件中随机选择一个入口，然后把它以字符的形式返回。GUI 由几多行的文本框组成，用于关闭程序的按钮和用于获取另一个 fortune 的按钮，以及一个用于显示该程序的编写者和版本号的介绍的按钮。这种根据任务来对代码进行分类的方法是一个很好的习惯，这有助于提高代码的复用性。</p>
</div>
<div class="section" id="bfile">
<h2><a class="toc-backref" href="#id8">BFile：使文件完全按照要求“端坐”和“犬吠”</a><a class="headerlink" href="#bfile" title="永久链接至标题">¶</a></h2>
<p>通常我们不能够让文件像忠实的小狗一样听话，但是 BFile 类是非常有用，它给了我们一个选择，让我们可以对一个文件进行任何的操作：创建文件，读取文件，撤销甚至清除数据，因为它是 BNode 的子类，当然我们以为它添加，删除或者修改属性。对于那些不熟悉的东西，属性是 BeOS 的一个特性：文件的描述数据不是文件数据的一部分，但是这不是我们这一节的重点。下面是 BFile 类中我们最常使用的方法的列表：</p>
<p>为一个 BFile 设置一个位置，这不仅仅是给予一个文件路径那么简单。实际上 SetTo() 有四个不同的版本。他们可以接收开放模式和字符路径，一个 BEntry，一个 entry_ref，或者一个字符格式相对路径的 BDirectory。开放模式是一个组合，一个由包含下面读或者写模式的标记的组合：</p>
<p>BFile 的构造函数和他们的 SetTo() 调用使用相同的参数，但是他们不返回任何的错误代码。在处理文件时，会出现任何可能的错误，所以一定要确保在创建一个 BFile 后，及时检查由 SetTo() 或者 InitCheck() 调用返回的错误信息。同时需要注意的是，在任何给定时间，系统只能够处理一定数量的文件。在设置好路径后，每一个 BEntry、BFile、BNode 或者 BDirectory 只能使用一个路径，所以在处理完成之后，Unset() 或者删除它们。</p>
</div>
<div class="section" id="id3">
<h2><a class="toc-backref" href="#id9">使用 BFile 读和写文件</a><a class="headerlink" href="#id3" title="永久链接至标题">¶</a></h2>
<p>BFile 使文件的读取非常容易。Read() 函数获取一个未类型化的字节缓冲区和将要读取的数据量以便从文件接收数据。在处理下一个数据时，通常你需要使用一个 char 阵列，或者一个 BString。下面是使用 BFile 和 BString 来读取文件的方法：</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">status_t</span>
<span class="nf">ReadFile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">B_BAD_VALUE</span><span class="p">;</span>

    <span class="c1">// Set up the file to read</span>
    <span class="n">BFile</span> <span class="n">file</span><span class="p">(</span><span class="s">&quot;/boot/home/Desktop/MyFile.txt&quot;</span><span class="p">,</span> <span class="n">B_READ_ONLY</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">InitCheck</span><span class="p">()</span> <span class="o">!=</span> <span class="n">B_OK</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t read the file</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">B_ERROR</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">off_t</span> <span class="n">fileSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">file</span><span class="p">.</span><span class="n">GetSize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fileSize</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fileSize</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;File is empty, so no data to read</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">B_OK</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Create a buffer to hold the file data</span>
    <span class="n">BString</span> <span class="n">fileData</span><span class="p">;</span>

    <span class="c1">// We can&#39;t directly pass a BString to Read(), so we&#39;ll use the BString</span>
    <span class="c1">// method LockBuffer() to get a pointer to its internal storage. While the</span>
    <span class="c1">// BString is locked, we can&#39;t use any of its methods, but we can make</span>
    <span class="c1">// whatever changes we want to the internal string array that it uses.</span>
    <span class="c1">// LockBuffer() takes an integer of the maximum size that the array will</span>
    <span class="c1">// be expected to be. We&#39;ll pad the number just in case so that there are</span>
    <span class="c1">// no unexpected crashes.</span>
    <span class="kt">char</span> <span class="o">*</span><span class="n">buffer</span> <span class="o">=</span> <span class="n">fileData</span><span class="p">.</span><span class="n">LockBuffer</span><span class="p">(</span><span class="n">fileSize</span> <span class="o">+</span> <span class="mi">10</span><span class="p">);</span>

    <span class="c1">// Read() will return the number of bytes actually read, but we&#39;re going</span>
    <span class="c1">// to ignore the value because we&#39;re reading in the entire file.</span>
    <span class="n">file</span><span class="p">.</span><span class="n">Read</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="n">fileSize</span><span class="p">);</span>

    <span class="c1">// Unlock the BString so we can use its methods again.</span>
    <span class="n">fileData</span><span class="p">.</span><span class="n">UnlockBuffer</span><span class="p">();</span>

    <span class="k">return</span> <span class="n">B_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>写入文件更加简单。Write() 函数同 Read() 函数有相同的参数，但是不同的是，Read() 把数据从文件拷入缓冲区，而 Write() 则把数据从缓冲区拷入文件。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="kt">void</span>
<span class="nf">WriteFile</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">path</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">path</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;NULL path sent to WriteFile</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">B_BAD_VALUE</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Create a file, if needed, and make it both readable and writable</span>
    <span class="n">BFile</span> <span class="n">file</span><span class="p">(</span><span class="n">path</span><span class="p">,</span><span class="n">B_READ_WRITE</span> <span class="o">|</span> <span class="n">B_CREATE_FILE</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">InitCheck</span><span class="p">()</span> <span class="o">!=</span> <span class="n">B_OK</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">printf</span><span class="p">(</span><span class="s">&quot;Couldn&#39;t write file &amp;s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">path</span><span class="p">);</span>
        <span class="k">return</span> <span class="n">B_ERROR</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="kt">char</span> <span class="n">testString</span><span class="p">[]</span> <span class="o">=</span> <span class="s">&quot;This is some file data.</span><span class="se">\n</span><span class="s">It&#39;s not really important.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="n">file</span><span class="p">.</span><span class="n">Write</span><span class="p">(</span><span class="n">testString</span><span class="p">,</span><span class="n">strlen</span><span class="p">(</span><span class="n">testString</span><span class="p">));</span>
    <span class="k">return</span> <span class="n">B_OK</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="haikufortune">
<h2><a class="toc-backref" href="#id10">开始我们的项目：HaikuFortune</a><a class="headerlink" href="#haikufortune" title="永久链接至标题">¶</a></h2>
<ul class="simple">
<li>打开 Paladin，使用 MainWindow 模板创建一个新的 GUI 项目。</li>
<li>按下 Alt+N，或者从 Project menu（项目菜单）选择 New File（新建文件），然后创建一个 FortuneFunctions.cpp 文件。一定要检查文本框中是否创建了一个相同的头文件。</li>
</ul>
<p>我们要做的第一件事是设计一个类，该类从 fortune 目录中获取 fortune。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#ifndef FORTUNEFUNCTIONS_H</span>
<span class="cp">#define FORTUNEFUNCTIONS_H</span>

<span class="cp">#include &lt;List.h&gt;</span>
<span class="cp">#include &lt;String.h&gt;</span>
<span class="k">extern</span> <span class="n">BString</span> <span class="n">gFortunePath</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">FortuneAccess</span>
<span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
    <span class="n">FortuneAccess</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="n">FortuneAccess</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">folder</span><span class="p">);</span>
    <span class="o">~</span><span class="n">FortuneAccess</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="kt">status_t</span>        <span class="nf">SetFolder</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">folder</span><span class="p">);</span>
    <span class="kt">status_t</span>        <span class="nf">GetFortune</span><span class="p">(</span><span class="n">BString</span> <span class="o">&amp;</span><span class="n">target</span><span class="p">);</span>
    <span class="n">int32</span>           <span class="n">CountFiles</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="kt">status_t</span>        <span class="nf">LastFilename</span><span class="p">(</span><span class="n">BString</span> <span class="o">&amp;</span><span class="n">target</span><span class="p">);</span>

    <span class="k">private</span><span class="o">:</span>
    <span class="kt">void</span>            <span class="n">ScanFolder</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="n">Void</span>            <span class="nf">MakeEmpty</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
    <span class="n">BString</span>                 <span class="n">fPath</span><span class="p">,</span> <span class="n">fLastFile</span><span class="p">;</span>
    <span class="n">BList</span>           <span class="n">fRefList</span><span class="p">;</span>
<span class="p">};</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p>在这个类中，每一个方法都是有其用途的。首先，创建两个不同的析构函数时为了创建一个 FortuneAccess 对象的方便；在对象实例化时，不必考虑我们对于所要搜索的文件夹是否有所了解。SetFolder() 允许我们按照自己的意愿改变文件夹。GetFortune() 是我们在首要位置创建给类的主要原因：一个可复用的从指定文件夹中获取 fortune 的对象。CountFiles() 显示可用文件的数量。LastFilename() 显示最近的 fortune 中的文件名。ScanFolder() 贯穿整个目录，并且编译一个理论上应该包含 fortune 的可用的文件列表。</p>
<p>MakeEmpty() 是一个清除函数，在这里有必要对它进行一个简短的介绍。在 Fortune 文件夹中设置的文件名列表作为 entry_ref 对象的集合保存在一个 BList 中。对于 BList，有两个问题：当我们访问 static_cast 中的一个对象时，我们需要 static_cast，由于 BList 非常关注在它内部的内存分配，当列表被释放的时候，我们给予他的项目并没有被清除。这就意味着，我们必须手动的遍历类表，获取每个项目，然后进行释放。这是一个瓶颈，但很不幸的是，这是所有我们目前所拥有的。也许将来会有更好的解决办法，可是我们必须等下一次了，现在这对于我们的项目已经足够了。</p>
<p>下面是我们整个类的框架，包括每个函数的功能。那么你的工作就是写出这些代码。</p>
<div class="highlight-cpp"><div class="highlight"><pre><span class="cp">#include &quot;FortuneFunctions.h&quot;</span>

<span class="cp">#include &lt;Directory.h&gt;</span>
<span class="cp">#include &lt;Entry.h&gt;</span>
<span class="cp">#include &lt;File.h&gt;</span>
<span class="cp">#include &lt;OS.h&gt;</span>
<span class="cp">#include &lt;Path.h&gt;</span>

<span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>
<span class="cp">#include &lt;string.h&gt;</span>

<span class="c1">// Initialize the global path to a hardcoded value just in case.</span>
<span class="c1">// This happens to be different under Haiku than under previous versions</span>
<span class="c1">// of BeOS</span>
<span class="n">BString</span> <span class="n">gFortunePath</span> <span class="o">=</span> <span class="s">&quot;/boot/system/data/fortunes&quot;</span><span class="p">;</span>

<span class="n">FortuneAccess</span><span class="o">::</span><span class="n">FortuneAccess</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
<span class="p">}</span>

<span class="n">FortuneAccess</span><span class="o">::</span><span class="n">FortuneAccess</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">folder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">SetFolder</span><span class="p">(</span><span class="n">folder</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">FortuneAccess</span><span class="o">::~</span><span class="n">FortuneAccess</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Free all items in our list</span>
<span class="p">}</span>

<span class="kt">status_t</span>
<span class="n">FortuneAccess</span><span class="o">::</span><span class="n">SetFolder</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">folder</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Make sure that folder is valid and return B_BAD_VALUE if it isn&#39;t.</span>
    <span class="c1">// Set the path variable, scan the folder, and return B_OK</span>
<span class="p">}</span>

<span class="kt">status_t</span>
<span class="n">FortuneAccess</span><span class="o">::</span><span class="n">GetFortune</span><span class="p">(</span><span class="n">BString</span> <span class="o">&amp;</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Here&#39;s the meat of this class:</span>
    <span class="c1">// 1) Return B_NO_INIT if fPath is empty</span>
    <span class="c1">// 2) Return B_ERROR if the ref list is empty</span>

    <span class="c1">// 3) This line will randomly choose the index of a file in the ref list</span>
    <span class="n">int32</span> <span class="n">index</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">rand</span><span class="p">())</span> <span class="o">/</span> <span class="n">RAND_MAX</span> <span class="o">*</span> <span class="n">fRefList</span><span class="p">.</span><span class="n">CountItems</span><span class="p">());</span>

    <span class="c1">// 4) Get a pointer to the randomly-selected entry_ref</span>
    <span class="c1">// 5) Create and initialize a BFile object in read-only mode</span>
    <span class="c1">// 6) Check to make sure that the BFile&#39;s status is B_OK</span>
    <span class="c1">// 7) Set fLastFile to the name property of the ref we just</span>
    <span class="c1">// 8) Get the file&#39;s size.</span>
    <span class="c1">// 9) If the file is empty, return B_ERROR.</span>

    <span class="c1">// 10) Create a BString to hold the data in the file</span>
    <span class="c1">// 11) Create a char pointer that we&#39;ll use in BFile::Read.</span>

    <span class="c1">// 12) Initialize the pointer using BString::LockBuffer, passing the file&#39;s</span>
    <span class="c1">//       size + 10 bytes (for safety) as the size. LockBuffer temporarily gives</span>
    <span class="c1">//       you access to the BString&#39;s internal char array. We&#39;ll need this to</span>
    <span class="c1">//       be able to read the file&#39;s data into the BString.</span>

    <span class="c1">// 13) Use BFile::Read() to read the entire file using our new char pointer.</span>
    <span class="c1">// 14) Call BString::UnlockBuffer() to invalidate our char pointer and</span>
    <span class="c1">//      allow us to use regular BString methods again.</span>

    <span class="c1">// 15) Use a loop to manually count the number of record separators in the</span>
    <span class="c1">//      fortune file. The separator is the string &quot;%\n&quot;, so use a</span>
    <span class="c1">//      combination of BString::FindFirst and offsets in a loop to count them.</span>
    <span class="c1">// 16) Use this line to randomly choose an entry.</span>
    <span class="n">int32</span> <span class="n">entry</span> <span class="o">=</span> <span class="n">int32</span><span class="p">(</span><span class="kt">float</span><span class="p">(</span><span class="n">rand</span><span class="p">())</span> <span class="o">/</span> <span class="n">RAND_MAX</span> <span class="o">*</span> <span class="p">(</span><span class="n">entrycount</span> <span class="o">-</span> <span class="mi">1</span><span class="p">));</span>

    <span class="c1">// 17) Use FindFirst again to find the starting offset of this</span>
    <span class="c1">//       randomly-chosen entry in the file.</span>
    <span class="c1">// 18) Call FindFirst one last time to find the offset of the next separator</span>
    <span class="c1">//       so we know how long the fortune is.</span>
    <span class="c1">// 19) Create a BString to hold the fortune.</span>
    <span class="c1">// 20) Set this new BString to the String() method plus the starting offset</span>
    <span class="c1">//       of the BString holding the file data. This will effectively chop out</span>
    <span class="c1">//       everything that is before our fortune in the file. It should look</span>
    <span class="c1">//       something like this:</span>
    <span class="c1">//       BString fortune = filedata.String() + startingOffset;</span>
    <span class="c1">// 21) Chop off everything after our fortune in the fortune BString by</span>
    <span class="c1">//       calling its Truncate() method.</span>
    <span class="c1">//       Hint: length = endingOffset – startingOffset + 2</span>
    <span class="c1">// 22) Set the parameter &#39;target&#39; to our fortune data and return B_OK</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">FortuneAccess</span><span class="o">::</span><span class="n">ScanFolder</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Use a BDirectory for this. Make sure that it is initialized from fPath</span>
    <span class="c1">// properly. Empty the ref list so that we&#39;re not adding to an existing</span>
    <span class="c1">// list. Use BDirectory::GetNextEntry to get the entry for each file in the</span>
    <span class="c1">// folder. Use the BEntry to check to make sure that the entry is a file,</span>
    <span class="c1">// and, assuming so, make a new entry_ref, send it to BEntry::GetRef,</span>
    <span class="c1">// and add it to our ref list.</span>
<span class="p">}</span>

<span class="kt">void</span>
<span class="n">FortuneAccess</span><span class="o">::</span><span class="n">MakeEmpty</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Iterate through the ref list and delete each entry_ref. After doing</span>
    <span class="c1">// this, call BList::MakeEmpty().</span>
<span class="p">}</span>

<span class="n">int32</span>
<span class="n">FortuneAccess</span><span class="o">::</span><span class="n">CountFiles</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
    <span class="k">return</span> <span class="n">fRefList</span><span class="p">.</span><span class="n">CountItems</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">status_t</span>
<span class="n">FortuneAccess</span><span class="o">::</span><span class="n">LastFilename</span><span class="p">(</span><span class="n">BString</span> <span class="o">&amp;</span><span class="n">target</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Return B_NO_INIT if the path variable is empty</span>
    <span class="c1">// Set the target parameter to our fLastFile property and return B_OK</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="id4">
<h2><a class="toc-backref" href="#id11">编写和测试代码</a><a class="headerlink" href="#id4" title="永久链接至标题">¶</a></h2>
<p>由于我们在处理不包含 GUI 的代码，所以在终端中测试所有的代码将会及其容易。在 App.cpp 的 main() 函数中，注释除了返回值外的所有代码，并且快速的编写代码以确保所有的代码都能够正确的运行。下面是一些建议，希望能够使程序的编写变得更加容易：</p>
<ul class="simple">
<li>首先编写析构函数和 MakeEmpty() 函数。</li>
<li>接下来实现 SetFolder()。</li>
<li>由于 GetFortune() 依赖于 ScanFolder()，所以接下来应该编写 ScanFolder() 函数。Main() 函数中的测试代码应该只调用 SetFolder()，并且设置你希望用作测试的路径。使用 printf() 输出显示 ScanFolder() 正在处理的任务将会是一种比较好的调试方法，例如，搜索到的每一个 ref 的名字。</li>
<li>一旦 ScanFolder() 编写完成，就需要开始 GetFortune() 的实现。完成之后，使用 printf() 找出进展状况。</li>
<li>你可以根据自己的情况来实现 LastFileName() 函数，在我们开始实现 GUI 之前，它并不是很重要。</li>
</ul>
<p>如果你的 FortuneAccess 类完成并且经过了测试，你应该在其基础之上编写一个比 fortune 本身更好的命令行下的 fortune 程序。</p>
</div>
<div class="section" id="id5">
<h2><a class="toc-backref" href="#id12">深入学习</a><a class="headerlink" href="#id5" title="永久链接至标题">¶</a></h2>
<p>直到现在，我们还没有接触到 GUI。好好考虑一下这个问题，如何利用图形控件制作一个简单的界面来展示 fortune。接下来，学习了 GUI 的有关内容之后，我们的项目将会得到完善。</p>
</div>
</div>


          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; 版权所有 2015, Haiku Chinese Group.
      最后更新于 Aug 18, 2016.
    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/snide/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>.

</footer>

        </div>
      </div>

    </section>

  </div>
  


  

    <script type="text/javascript">
        var DOCUMENTATION_OPTIONS = {
            URL_ROOT:'../../../',
            VERSION:'0.1',
            COLLAPSE_INDEX:false,
            FILE_SUFFIX:'.html',
            HAS_SOURCE:  true
        };
    </script>
      <script type="text/javascript" src="../../../_static/jquery.js"></script>
      <script type="text/javascript" src="../../../_static/underscore.js"></script>
      <script type="text/javascript" src="../../../_static/doctools.js"></script>
      <script type="text/javascript" src="../../../_static/translations.js"></script>

  

  
  
    <script type="text/javascript" src="../../../_static/js/theme.js"></script>
  

  
  
  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.StickyNav.enable();
      });
  </script>
   

</body>
</html>