<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>第十八课 &mdash; Haiku 中文文档</title>
    
    <link rel="stylesheet" href="../../../_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="../../../_static/pygments.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '../../../',
        VERSION:     '0.1',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="../../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../../_static/doctools.js"></script>
    <link rel="top" title="Haiku 中文文档" href="../../../index.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="../../../index.html">
          <span>Haiku 中文文档</span></a></h1>
        <h2 class="heading"><span>第十八课</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="id1">
<h1>第十八课<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h1>
<p>我们已经学了有关菜单和按钮的内容，接下来我们将要开始学习其他可用的窗口控件类型，如下表所示：</p>
<p>![](./pictures/lesson_18_table.gif)</p>
<p>上面给出了很多不同的类！乍看之下，乱花迷眼，但略加提炼，抑或稍加思考，您会发现她们形貌相仿，并非全异。您可能希望将这张表放在手边，以备不时之需。我们并不会对上述每个类都详细阐述，所略过的类都比较简单，非常易于理解。</p>
<p>## 重访类型转换</p>
<p>返回第七节，我们了解了类型转换，例如，将变量中的数据转译为其他不同的类型。在 C 语言中进行转换时存在的问题之一就是安全性 - 无论何时进行转换，它总会成功。如果您选择一个错误的类进行转换，它仍然会成功，这显然会造成无法预期的结果。C++ 提供了不同类型的转换。并且推荐使用 C++ 的转换方式，除非您是在编写 C 代码。如下所示：
<tt class="docutils literal"><span class="pre">`C++</span>
<span class="pre">static_cast&lt;TypeToCastTo</span> <span class="pre">*&gt;(pointerToCast);</span>
<span class="pre">`</span></tt>
static 转换用于将一种类型转换为其他类型。它依赖于编译期信息，并且通常用于常用的C转换方法的目的 - 修改指针类型和算术转换。仅当 C++ 语言支持的两种类型之间的转换时，它才会成功。
<tt class="docutils literal"><span class="pre">`C++</span>
<span class="pre">dynamic_cast&lt;TypeToCastTo</span> <span class="pre">*&gt;(pointerToCast);</span>
<span class="pre">`</span></tt>
和 static 转换不同，dynamic 转换将会是 Haiku 编程中最常用的转换类型方式。它们用于安全得导航到一个继承体系。如果继承没有将 “from” 和 “to” 类型链接到一起，那么就会返回 NULL。这样，您就仅可以转换为这些您认为可以转换的指针类型。我们将会在这节的项目中用到它们。
<tt class="docutils literal"><span class="pre">`C++</span>
<span class="pre">const_cast&lt;TypeToCastTo</span> <span class="pre">*&gt;(pointerToCast);</span>
<span class="pre">`</span></tt>
const 转换将会添加或者移除指针的可变度。例如，有一些实例中，函数将会接受一个非 const 参数，但不能够对其进行修改。传递一个常量指针给这些函数将会需要进行 const 转换。
<tt class="docutils literal"><span class="pre">`C++</span>
<span class="pre">reinterpret_cast&lt;TypeToCastTo</span> <span class="pre">*&gt;(pointerToCast&gt;;</span>
<span class="pre">`</span></tt>
reinterpret_cast 转换很少使用。它将一个指针从一种类型转换为其他类型，而忽略这两者之间的相关性。基本上所有 reinterpret 转换可以完成的任务都可以由 static 转换来完成，并且其他的转换通常都不可移植，因此这种类型的转换仅用于确实需要的地方，例如转换函数指针类型。</p>
<p>## 项目：使用列表控件</p>
<p>本项目，称为 ListTitle，将会使用列表控件，即 BListView 类。在 Haiku API 中发现基于列表的控件使用轻量级的条目。BMenu 和BListView 实际上完成了大部分的工作，而 BMenuItem 和 BListItem 则是非常简单的类。以下面的方式设计类将会节约内存。</p>
<ol class="arabic simple">
<li>在 Paladin 中新建一个项目，但是这次使用 “GUI with Main Window” 模板以节约部分输入 - 这个模板将会为 App 和 MainWindow 类创建基本的代码。</li>
<li>我们的项目和目标命名为 ListTitile。</li>
<li>完成创建后，打开 App.cpp，修改程序的 MIME 标识为 “application/x-vnd.test-ListTitle”，然后关闭。</li>
<li>打开 MainWindow.h，在其顶部添加 ListView.h 头文件。</li>
<li>在 MainWindow 类定义底部添加添加一个 “private:” 访问标号关键字。</li>
<li>在 MainWindow 定义的 private 块中，声明属性 BListView <a href="#id2"><span class="problematic" id="id3">*</span></a>fListView。我们不仅仅在窗口构造函数中使用 fListView，因此使用指针将很有必要。</li>
</ol>
<p>您的 App 类文件和 MainWindow.h 文件应该如下所示：</p>
<div class="section" id="app-h">
<h2>App.h<a class="headerlink" href="#app-h" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><a href="#id4"><span class="problematic" id="id5">``</span></a><a href="#id6"><span class="problematic" id="id7">`</span></a>C++</dt>
<dd><p class="first">#ifndef APP_H
#define APP_H
#include &lt;Application.h&gt;
class App : public BApplication
{</p>
<blockquote>
<div>public:
App(void);</div></blockquote>
<p class="last">};
#endif</p>
</dd>
</dl>
<p><a href="#id8"><span class="problematic" id="id9">``</span></a>`
App.cpp
&#8212;&#8212;&#8212;&#8212;
<a href="#id10"><span class="problematic" id="id11">``</span></a><a href="#id12"><span class="problematic" id="id13">`</span></a>C++</p>
<blockquote>
<div><p>#include &#8220;App.h&#8221;
#include &#8220;MainWindow.h&#8221;
App::App(void)
: BApplication(&#8220;application/x-vnd.test-ListColors&#8221;)
{</p>
<blockquote>
<div>MainWindow <a href="#id14"><span class="problematic" id="id15">*</span></a>mainwin = new MainWindow();
mainwin-&gt;Show();</div></blockquote>
<p>}</p>
<p>int
main(void)
{</p>
<blockquote>
<div>App <a href="#id16"><span class="problematic" id="id17">*</span></a>app = new App();
app-&gt;Run();
delete app;
return 0;</div></blockquote>
<p>}</p>
</div></blockquote>
<p><a href="#id18"><span class="problematic" id="id19">``</span></a>`
MainWindow.h
&#8212;&#8212;&#8212;&#8212;-
<a href="#id20"><span class="problematic" id="id21">``</span></a><a href="#id22"><span class="problematic" id="id23">`</span></a>C++</p>
<blockquote>
<div><p>#ifndef MAINWINDOW_H
#define MAINWINDOW_H
#include &lt;Window.h&gt;
#include &lt;ListView.h&gt;
class MainWindow : public BWindow
{
public:</p>
<blockquote>
<div>MainWindow(void);
void MessageReceived(BMessage <a href="#id24"><span class="problematic" id="id25">*</span></a>msg);</div></blockquote>
<dl class="docutils">
<dt>private:</dt>
<dd>BListView <a href="#id26"><span class="problematic" id="id27">*</span></a>fListView;</dd>
</dl>
<p>};
#endif</p>
</div></blockquote>
<p><a href="#id28"><span class="problematic" id="id29">``</span></a>`
现在进入正题：设置 MainWindow 的控件并且让它们有所动作。
打开 MainWindow.cpp，然后做如下修改：</p>
</div>
<div class="section" id="mainwindow-cpp">
<h2>MainWindow.cpp<a class="headerlink" href="#mainwindow-cpp" title="Permalink to this headline">¶</a></h2>
<dl class="docutils">
<dt><a href="#id30"><span class="problematic" id="id31">``</span></a><a href="#id32"><span class="problematic" id="id33">`</span></a>C++</dt>
<dd><p class="first">#include &#8220;MainWindow.h&#8221;
#include &lt;Button.h&gt;
#include &lt;ListItem.h&gt;
#include &lt;ScrollView.h&gt;</p>
<p>enum
{</p>
<blockquote>
<div>M_RESET_WINDOW = &#8216;rswn&#8217;,
M_SET_TITLE = &#8216;sttl&#8217;</div></blockquote>
<p>};</p>
<dl class="docutils">
<dt>MainWindow::MainWindow(void)</dt>
<dd><dl class="first last docutils">
<dt>:       BWindow(BRect(100,100,500,400),&#8221;The Weird World of Sports&#8221;,</dt>
<dd>B_TITLED_WINDOW, B_ASYNCHRONOUS_CONTROLS | B_QUIT_ON_WINDOW_CLOSE)</dd>
</dl>
</dd>
</dl>
<dl class="docutils">
<dt>{</dt>
<dd><p class="first">// 下面我们将创建一个BView，它将覆盖窗口内部所有白色区域，这样
// 我们就可以选择一个背景颜色。您将会希望在你的项目的窗口中这样
// 做 &#8211; 您的项目看起来将会很专业。
BRect r(Bounds());
BView <a href="#id34"><span class="problematic" id="id35">*</span></a>top = new BView(r,&#8221;topview&#8221;,B_FOLLOW_ALL,B_WILL_DRAW);
AddChild(top);</p>
<p>// ui_color()返回一个系统颜色，例如窗口标签颜色，菜单文本颜色，
// 等等。Panel Background颜色用于背景视图，如下所示。
top-&gt;SetViewColor(ui_color(B_PANEL_BACKGROUND_COLOR));</p>
<p>// 创建一个按钮，并将其放置在窗口的右下角。
// 用于BButton图框的BRect是空的，是因为我们将让其重设其尺寸，然
// 后根据按键的实际大小将其移动到右下角，因此无需指定其尺寸。
BButton <a href="#id36"><span class="problematic" id="id37">*</span></a>reset = new BButton(BRect(), &#8220;resetbutton&#8221;, &#8220;Reset&#8221;,</p>
<blockquote>
<div>new BMessage(M_RESET_WINDOW),
B_FOLLOW_RIGHT | B_FOLLOW_BOTTOM);</div></blockquote>
<p>top-&gt;AddChild(reset);
reset-&gt;ResizeToPreferred();</p>
<p>// 将按钮放置到窗口右下角，按钮与窗口边界的间隙为10个像素。
// 10个像素某种程度上说是用于控件填充的事实标准。它已经足以
// 让控件看起来不拥挤，并且也不占用大量空间。
reset-&gt;MoveTo(Bounds().right - reset-&gt;Bounds().Width() - 10.0,
Bounds().bottom - reset-&gt;Bounds().Height() - 10.0);
r = Bounds();
r.InsetBy(10.0,10.0);</p>
<p>// 使用BScrollView，在确定关联到BScrollView的控件尺寸时，您
// 必须补偿用于滚动栏的宽度/高度。B_V_SCROLL_BAR_WIDTH是用于
// 水平滚动栏宽度的已定义常量。
r.right -= B_V_SCROLL_BAR_WIDTH;</p>
<p>// 图框和Bounds()原理相似，除了它会返回控件在父视图坐标空间内
// 的尺寸和位置。这会使fListView得底部停靠在控件上方 10 个像素
// 的地方。
r.bottom = reset-&gt;Frame().top - 10.0 - B_H_SCROLL_BAR_HEIGHT;</p>
<p>// 这些参数多数和BView相同，除了我们也可以指定是否用户能够在列
// 表中选择单个条目或者点击条目时按下键盘上修饰键选择多个项目。
fListView = new BListView(r, &#8220;colorlist&#8221;, B_SINGLE_SELECTION_LIST,</p>
<blockquote>
<div>B_FOLLOW_ALL);</div></blockquote>
<p>// 我们在fListView上并未调用AddChild(),因为BScrollView将会为我们
// 完成这个操作。创建时，它创建了滚动栏并且把指定的视图作为其执行
// 滚动时的目标。在BScrollView关联到窗口时，它会为我们调用fListView
// 上的AddChild()。
// 如果我们在创建滚动视图前，调用了fListView的AddChild()，当我们在
// BScrollView中调用AddChild()时，我们的程序将进入调试器 &#8211; 一个视
// 图仅可以有一个父视图。
BScrollView <a href="#id38"><span class="problematic" id="id39">*</span></a>scrollView = new BScrollView(&#8220;scrollview&#8221;, fListView,</p>
<blockquote>
<div>B_FOLLOW_ALL, 0, true, true);</div></blockquote>
<p>top-&gt;AddChild(scrollView);</p>
<p>// 任何时候列表选择状态发生改变，都会向窗口发送 BListView
// 的选择消息。
fListView-&gt;SetSelectionMessage(new BMessage(M_SET_TITLE));</p>
<p class="last">fListView-&gt;AddItem(new BStringItem(&#8220;Toe Wrestling&#8221;));
fListView-&gt;AddItem(new BStringItem(&#8220;Electric Toilet Racing&#8221;));
fListView-&gt;AddItem(new BStringItem(&#8220;Bog Snorkeling&#8221;));
fListView-&gt;AddItem(new BStringItem(&#8220;Chess Boxing&#8221;));
fListView-&gt;AddItem(new BStringItem(&#8220;Cheese Rolling&#8221;));
fListView-&gt;AddItem(new BStringItem(&#8220;Unicycle Polo&#8221;));</p>
</dd>
</dl>
<p>}</p>
<p>void
MainWindow::MessageReceived(BMessage <a href="#id40"><span class="problematic" id="id41">*</span></a>msg)
{</p>
<blockquote>
<div><p>switch (msg-&gt;what)
{</p>
<blockquote>
<div><p>case M_RESET_WINDOW:
{</p>
<blockquote>
<div>fListView-&gt;DeselectAll();
break;</div></blockquote>
<p>}
case M_SET_TITLE:
{</p>
<blockquote>
<div><p>int32 selection = fListView-&gt;CurrentSelection();
if (selection &lt; 0)
{</p>
<blockquote>
<div>// 这个代码之所以在这里是因为我们按下 Reset按钮时，
// 选取状态改变，并发送 M_SET_TITLE。但是由于并未
// 选中任何内容，CurrentSelection()返回 -1。
SetTitle(&#8220;The Weird World of Sports&#8221;);
break;</div></blockquote>
<p>}</p>
<dl class="docutils">
<dt>BStringItem <em>item = dynamic_cast&lt;BStringItem</em>&gt;(</dt>
<dd>fListView-&gt;ItemAt(selection));</dd>
<dt>if (item)</dt>
<dd>SetTitle(item-&gt;Text());</dd>
</dl>
<p>break;</p>
</div></blockquote>
<p>}</p>
<p>default:
{</p>
<blockquote>
<div>BWindow::MessageReceived(msg);
break;</div></blockquote>
<p>}</p>
</div></blockquote>
<p>}</p>
</div></blockquote>
<p class="last">}</p>
</dd>
</dl>
<p><a href="#id42"><span class="problematic" id="id43">``</span></a>`
这个项目和上节中的项目并没有太多不同之处。通过调用 BListView 的 SetSelectionMessage() 方法，我们让标题能够在用于点击列表中的条目时及时进行更新。通常我们使用 BListView 时，并不会使用这个方法。相对使用更加频繁的是：</p>
<p>SetInvocationMessage()，用于在用于双击条目时发送消息。需要注意的是，DeselectAll() 也会引起选中消息的发送，即使并没有选择，因此有必要处理这种情况，当 CurrentSelection() 返回负值时，标明没有选择。
幸好您已经对 BView 和常用控件如何一起应用到程序中有所感觉。它们大多数都需要使用 BRect 标识其尺寸和位置，const char * 标识控件名称的，两个整型标识其尺寸修改模式和其他的行为标志。许多类也具有标签和当控件修改或调用时发送的消息，有其是那些继承自 BControl 的类。控件创建后，它将通过 AddChile() 函数关联到 BWindow 或 BView。控件发送的消息通常发送到其所关联到的窗口，但是它也可以定位到其他目标，例如其父类 BView 或者全局的 BApplication。</p>
<p>## 需要记住的内容</p>
<p>### BControl</p>
<ul class="simple">
<li>ResizeToPreferred(void) - 子类调用它调整自己至合适尺寸以显示其标签和内容。</li>
<li>SetLabel(const char <a href="#id44"><span class="problematic" id="id45">*</span></a>label)/const char * Label(void) - 用于获取和设置子类的标签的方法。</li>
<li>SetTarget(BHandler <a href="#id46"><span class="problematic" id="id47">*</span></a>handler, BLooper <a href="#id48"><span class="problematic" id="id49">*</span></a>looper) - 发送调用小弟到不同的目标，如 BView，BWindow，或者 BApplication。</li>
<li>void SetEnabled(bool enabled)/bool IsEnabled(void) - 用于获取和设置控件启用/禁用状态的方法。</li>
</ul>
<p>### BListView</p>
<ul class="simple">
<li>AddItem(BListItem <a href="#id50"><span class="problematic" id="id51">*</span></a>item) - 添加条目到列表。</li>
<li>int32 CountItems(void) - 返回列表中条目的数量。</li>
<li>BListItem <a href="#id52"><span class="problematic" id="id53">*</span></a>RemoveItem(int32 index) - 移除并返回指定索引的条目，如果不存在，则返回 NULL。</li>
<li>void RemoveItem(BListItem <a href="#id54"><span class="problematic" id="id55">*</span></a>item) - 从列表中移除指定条目。如果列表中不存在，则不作任何动作。</li>
<li>int32 CurrentSelection(int32 index = -1) - 返回当前选中项目的索引，如果不存在，则为 -1。index 参数用于获取支持多条目选择的列表中所有的选中项目。通常会有一个 while() 循环来获取所有的条目标记，并且当返回 -1 是，它将会退出。</li>
<li>void Select(itn32 index, bool extend = false) - 从指定索引中选择条目。如果extend为false，在指定条目选定前，所有其他的条目将会取消选定。</li>
<li>void Select(int32 start, int32 end, bool extend = false) - 选中 start 到 end 之间的所有条目。如果 extend 为 false，在指定条目选定前，其他的所有条目取消选定。</li>
<li>void DeselectAll(void) - 取消选定列表中的所有条目。</li>
</ul>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="../../../index.html">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2015, Han Pengfei.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.3.
    </div>
  </body>
</html>